{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\nimport { decodeNamedCharacterReference } from 'decode-named-character-reference';\nimport { asciiAlphanumeric, asciiDigit, asciiHexDigit } from 'micromark-util-character';\nimport { codes } from 'micromark-util-symbol/codes.js';\nimport { constants } from 'micromark-util-symbol/constants.js';\nimport { types } from 'micromark-util-symbol/types.js';\nimport { ok as assert } from 'uvu/assert';\n/** @type {Construct} */\n\nexport const characterReference = {\n  name: 'characterReference',\n  tokenize: tokenizeCharacterReference\n};\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\n\nfunction tokenizeCharacterReference(effects, ok, nok) {\n  const self = this;\n  let size = 0;\n  /** @type {number} */\n\n  let max;\n  /** @type {(code: Code) => boolean} */\n\n  let test;\n  return start;\n  /**\n   * Start of character reference.\n   *\n   * ```markdown\n   * > | a&amp;b\n   *      ^\n   * > | a&#123;b\n   *      ^\n   * > | a&#x9;b\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n\n  function start(code) {\n    assert(code === codes.ampersand, 'expected `&`');\n    effects.enter(types.characterReference);\n    effects.enter(types.characterReferenceMarker);\n    effects.consume(code);\n    effects.exit(types.characterReferenceMarker);\n    return open;\n  }\n  /**\n   * After `&`, at `#` for numeric references or alphanumeric for named\n   * references.\n   *\n   * ```markdown\n   * > | a&amp;b\n   *       ^\n   * > | a&#123;b\n   *       ^\n   * > | a&#x9;b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function open(code) {\n    if (code === codes.numberSign) {\n      effects.enter(types.characterReferenceMarkerNumeric);\n      effects.consume(code);\n      effects.exit(types.characterReferenceMarkerNumeric);\n      return numeric;\n    }\n\n    effects.enter(types.characterReferenceValue);\n    max = constants.characterReferenceNamedSizeMax;\n    test = asciiAlphanumeric;\n    return value(code);\n  }\n  /**\n   * After `#`, at `x` for hexadecimals or digit for decimals.\n   *\n   * ```markdown\n   * > | a&#123;b\n   *        ^\n   * > | a&#x9;b\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function numeric(code) {\n    if (code === codes.uppercaseX || code === codes.lowercaseX) {\n      effects.enter(types.characterReferenceMarkerHexadecimal);\n      effects.consume(code);\n      effects.exit(types.characterReferenceMarkerHexadecimal);\n      effects.enter(types.characterReferenceValue);\n      max = constants.characterReferenceHexadecimalSizeMax;\n      test = asciiHexDigit;\n      return value;\n    }\n\n    effects.enter(types.characterReferenceValue);\n    max = constants.characterReferenceDecimalSizeMax;\n    test = asciiDigit;\n    return value(code);\n  }\n  /**\n   * After markers (`&#x`, `&#`, or `&`), in value, before `;`.\n   *\n   * The character reference kind defines what and how many characters are\n   * allowed.\n   *\n   * ```markdown\n   * > | a&amp;b\n   *       ^^^\n   * > | a&#123;b\n   *        ^^^\n   * > | a&#x9;b\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function value(code) {\n    if (code === codes.semicolon && size) {\n      const token = effects.exit(types.characterReferenceValue);\n\n      if (test === asciiAlphanumeric && !decodeNamedCharacterReference(self.sliceSerialize(token))) {\n        return nok(code);\n      } // To do: `markdown-rs` uses a different name:\n      // `CharacterReferenceMarkerSemi`.\n\n\n      effects.enter(types.characterReferenceMarker);\n      effects.consume(code);\n      effects.exit(types.characterReferenceMarker);\n      effects.exit(types.characterReference);\n      return ok;\n    }\n\n    if (test(code) && size++ < max) {\n      effects.consume(code);\n      return value;\n    }\n\n    return nok(code);\n  }\n}","map":{"version":3,"sources":["D:/com lab/react/keerthana/auth2/AuthInMern/client/node_modules/micromark-core-commonmark/dev/lib/character-reference.js"],"names":["decodeNamedCharacterReference","asciiAlphanumeric","asciiDigit","asciiHexDigit","codes","constants","types","ok","assert","characterReference","name","tokenize","tokenizeCharacterReference","effects","nok","self","size","max","test","start","code","ampersand","enter","characterReferenceMarker","consume","exit","open","numberSign","characterReferenceMarkerNumeric","numeric","characterReferenceValue","characterReferenceNamedSizeMax","value","uppercaseX","lowercaseX","characterReferenceMarkerHexadecimal","characterReferenceHexadecimalSizeMax","characterReferenceDecimalSizeMax","semicolon","token","sliceSerialize"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {decodeNamedCharacterReference} from 'decode-named-character-reference'\nimport {\n  asciiAlphanumeric,\n  asciiDigit,\n  asciiHexDigit\n} from 'micromark-util-character'\nimport {codes} from 'micromark-util-symbol/codes.js'\nimport {constants} from 'micromark-util-symbol/constants.js'\nimport {types} from 'micromark-util-symbol/types.js'\nimport {ok as assert} from 'uvu/assert'\n\n/** @type {Construct} */\nexport const characterReference = {\n  name: 'characterReference',\n  tokenize: tokenizeCharacterReference\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeCharacterReference(effects, ok, nok) {\n  const self = this\n  let size = 0\n  /** @type {number} */\n  let max\n  /** @type {(code: Code) => boolean} */\n  let test\n\n  return start\n\n  /**\n   * Start of character reference.\n   *\n   * ```markdown\n   * > | a&amp;b\n   *      ^\n   * > | a&#123;b\n   *      ^\n   * > | a&#x9;b\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    assert(code === codes.ampersand, 'expected `&`')\n    effects.enter(types.characterReference)\n    effects.enter(types.characterReferenceMarker)\n    effects.consume(code)\n    effects.exit(types.characterReferenceMarker)\n    return open\n  }\n\n  /**\n   * After `&`, at `#` for numeric references or alphanumeric for named\n   * references.\n   *\n   * ```markdown\n   * > | a&amp;b\n   *       ^\n   * > | a&#123;b\n   *       ^\n   * > | a&#x9;b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function open(code) {\n    if (code === codes.numberSign) {\n      effects.enter(types.characterReferenceMarkerNumeric)\n      effects.consume(code)\n      effects.exit(types.characterReferenceMarkerNumeric)\n      return numeric\n    }\n\n    effects.enter(types.characterReferenceValue)\n    max = constants.characterReferenceNamedSizeMax\n    test = asciiAlphanumeric\n    return value(code)\n  }\n\n  /**\n   * After `#`, at `x` for hexadecimals or digit for decimals.\n   *\n   * ```markdown\n   * > | a&#123;b\n   *        ^\n   * > | a&#x9;b\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function numeric(code) {\n    if (code === codes.uppercaseX || code === codes.lowercaseX) {\n      effects.enter(types.characterReferenceMarkerHexadecimal)\n      effects.consume(code)\n      effects.exit(types.characterReferenceMarkerHexadecimal)\n      effects.enter(types.characterReferenceValue)\n      max = constants.characterReferenceHexadecimalSizeMax\n      test = asciiHexDigit\n      return value\n    }\n\n    effects.enter(types.characterReferenceValue)\n    max = constants.characterReferenceDecimalSizeMax\n    test = asciiDigit\n    return value(code)\n  }\n\n  /**\n   * After markers (`&#x`, `&#`, or `&`), in value, before `;`.\n   *\n   * The character reference kind defines what and how many characters are\n   * allowed.\n   *\n   * ```markdown\n   * > | a&amp;b\n   *       ^^^\n   * > | a&#123;b\n   *        ^^^\n   * > | a&#x9;b\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function value(code) {\n    if (code === codes.semicolon && size) {\n      const token = effects.exit(types.characterReferenceValue)\n\n      if (\n        test === asciiAlphanumeric &&\n        !decodeNamedCharacterReference(self.sliceSerialize(token))\n      ) {\n        return nok(code)\n      }\n\n      // To do: `markdown-rs` uses a different name:\n      // `CharacterReferenceMarkerSemi`.\n      effects.enter(types.characterReferenceMarker)\n      effects.consume(code)\n      effects.exit(types.characterReferenceMarker)\n      effects.exit(types.characterReference)\n      return ok\n    }\n\n    if (test(code) && size++ < max) {\n      effects.consume(code)\n      return value\n    }\n\n    return nok(code)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}
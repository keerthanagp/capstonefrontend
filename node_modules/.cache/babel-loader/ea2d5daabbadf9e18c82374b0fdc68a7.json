{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Exiter} Exiter\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownSpace } from 'micromark-util-character';\nimport { codes } from 'micromark-util-symbol/codes.js';\nimport { constants } from 'micromark-util-symbol/constants.js';\nimport { types } from 'micromark-util-symbol/types.js';\nimport { ok as assert } from 'uvu/assert';\n/** @type {Construct} */\n\nexport const blockQuote = {\n  name: 'blockQuote',\n  tokenize: tokenizeBlockQuoteStart,\n  continuation: {\n    tokenize: tokenizeBlockQuoteContinuation\n  },\n  exit\n};\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\n\nfunction tokenizeBlockQuoteStart(effects, ok, nok) {\n  const self = this;\n  return start;\n  /**\n   * Start of block quote.\n   *\n   * ```markdown\n   * > | > a\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n\n  function start(code) {\n    if (code === codes.greaterThan) {\n      const state = self.containerState;\n      assert(state, 'expected `containerState` to be defined in container');\n\n      if (!state.open) {\n        effects.enter(types.blockQuote, {\n          _container: true\n        });\n        state.open = true;\n      }\n\n      effects.enter(types.blockQuotePrefix);\n      effects.enter(types.blockQuoteMarker);\n      effects.consume(code);\n      effects.exit(types.blockQuoteMarker);\n      return after;\n    }\n\n    return nok(code);\n  }\n  /**\n   * After `>`, before optional whitespace.\n   *\n   * ```markdown\n   * > | > a\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function after(code) {\n    if (markdownSpace(code)) {\n      effects.enter(types.blockQuotePrefixWhitespace);\n      effects.consume(code);\n      effects.exit(types.blockQuotePrefixWhitespace);\n      effects.exit(types.blockQuotePrefix);\n      return ok;\n    }\n\n    effects.exit(types.blockQuotePrefix);\n    return ok(code);\n  }\n}\n/**\n * Start of block quote continuation.\n *\n * ```markdown\n *   | > a\n * > | > b\n *     ^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\n\n\nfunction tokenizeBlockQuoteContinuation(effects, ok, nok) {\n  const self = this;\n  return contStart;\n  /**\n   * Start of block quote continuation.\n   *\n   * Also used to parse the first block quote opening.\n   *\n   * ```markdown\n   *   | > a\n   * > | > b\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n\n  function contStart(code) {\n    if (markdownSpace(code)) {\n      // Always populated by defaults.\n      assert(self.parser.constructs.disable.null, 'expected `disable.null` to be populated');\n      return factorySpace(effects, contBefore, types.linePrefix, self.parser.constructs.disable.null.includes('codeIndented') ? undefined : constants.tabSize)(code);\n    }\n\n    return contBefore(code);\n  }\n  /**\n   * At `>`, after optional whitespace.\n   *\n   * Also used to parse the first block quote opening.\n   *\n   * ```markdown\n   *   | > a\n   * > | > b\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function contBefore(code) {\n    return effects.attempt(blockQuote, ok, nok)(code);\n  }\n}\n/** @type {Exiter} */\n\n\nfunction exit(effects) {\n  effects.exit(types.blockQuote);\n}","map":{"version":3,"sources":["D:/com lab/react/keerthana/auth2/AuthInMern/client/node_modules/micromark-core-commonmark/dev/lib/block-quote.js"],"names":["factorySpace","markdownSpace","codes","constants","types","ok","assert","blockQuote","name","tokenize","tokenizeBlockQuoteStart","continuation","tokenizeBlockQuoteContinuation","exit","effects","nok","self","start","code","greaterThan","state","containerState","open","enter","_container","blockQuotePrefix","blockQuoteMarker","consume","after","blockQuotePrefixWhitespace","contStart","parser","constructs","disable","null","contBefore","linePrefix","includes","undefined","tabSize","attempt"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,SAAQA,YAAR,QAA2B,yBAA3B;AACA,SAAQC,aAAR,QAA4B,0BAA5B;AACA,SAAQC,KAAR,QAAoB,gCAApB;AACA,SAAQC,SAAR,QAAwB,oCAAxB;AACA,SAAQC,KAAR,QAAoB,gCAApB;AACA,SAAQC,EAAE,IAAIC,MAAd,QAA2B,YAA3B;AAEA;;AACA,OAAO,MAAMC,UAAU,GAAG;AACxBC,EAAAA,IAAI,EAAE,YADkB;AAExBC,EAAAA,QAAQ,EAAEC,uBAFc;AAGxBC,EAAAA,YAAY,EAAE;AAACF,IAAAA,QAAQ,EAAEG;AAAX,GAHU;AAIxBC,EAAAA;AAJwB,CAAnB;AAOP;AACA;AACA;AACA;;AACA,SAASH,uBAAT,CAAiCI,OAAjC,EAA0CT,EAA1C,EAA8CU,GAA9C,EAAmD;AACjD,QAAMC,IAAI,GAAG,IAAb;AAEA,SAAOC,KAAP;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,WAASA,KAAT,CAAeC,IAAf,EAAqB;AACnB,QAAIA,IAAI,KAAKhB,KAAK,CAACiB,WAAnB,EAAgC;AAC9B,YAAMC,KAAK,GAAGJ,IAAI,CAACK,cAAnB;AAEAf,MAAAA,MAAM,CAACc,KAAD,EAAQ,sDAAR,CAAN;;AAEA,UAAI,CAACA,KAAK,CAACE,IAAX,EAAiB;AACfR,QAAAA,OAAO,CAACS,KAAR,CAAcnB,KAAK,CAACG,UAApB,EAAgC;AAACiB,UAAAA,UAAU,EAAE;AAAb,SAAhC;AACAJ,QAAAA,KAAK,CAACE,IAAN,GAAa,IAAb;AACD;;AAEDR,MAAAA,OAAO,CAACS,KAAR,CAAcnB,KAAK,CAACqB,gBAApB;AACAX,MAAAA,OAAO,CAACS,KAAR,CAAcnB,KAAK,CAACsB,gBAApB;AACAZ,MAAAA,OAAO,CAACa,OAAR,CAAgBT,IAAhB;AACAJ,MAAAA,OAAO,CAACD,IAAR,CAAaT,KAAK,CAACsB,gBAAnB;AACA,aAAOE,KAAP;AACD;;AAED,WAAOb,GAAG,CAACG,IAAD,CAAV;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACE,WAASU,KAAT,CAAeV,IAAf,EAAqB;AACnB,QAAIjB,aAAa,CAACiB,IAAD,CAAjB,EAAyB;AACvBJ,MAAAA,OAAO,CAACS,KAAR,CAAcnB,KAAK,CAACyB,0BAApB;AACAf,MAAAA,OAAO,CAACa,OAAR,CAAgBT,IAAhB;AACAJ,MAAAA,OAAO,CAACD,IAAR,CAAaT,KAAK,CAACyB,0BAAnB;AACAf,MAAAA,OAAO,CAACD,IAAR,CAAaT,KAAK,CAACqB,gBAAnB;AACA,aAAOpB,EAAP;AACD;;AAEDS,IAAAA,OAAO,CAACD,IAAR,CAAaT,KAAK,CAACqB,gBAAnB;AACA,WAAOpB,EAAE,CAACa,IAAD,CAAT;AACD;AACF;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASN,8BAAT,CAAwCE,OAAxC,EAAiDT,EAAjD,EAAqDU,GAArD,EAA0D;AACxD,QAAMC,IAAI,GAAG,IAAb;AAEA,SAAOc,SAAP;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,WAASA,SAAT,CAAmBZ,IAAnB,EAAyB;AACvB,QAAIjB,aAAa,CAACiB,IAAD,CAAjB,EAAyB;AACvB;AACAZ,MAAAA,MAAM,CACJU,IAAI,CAACe,MAAL,CAAYC,UAAZ,CAAuBC,OAAvB,CAA+BC,IAD3B,EAEJ,yCAFI,CAAN;AAKA,aAAOlC,YAAY,CACjBc,OADiB,EAEjBqB,UAFiB,EAGjB/B,KAAK,CAACgC,UAHW,EAIjBpB,IAAI,CAACe,MAAL,CAAYC,UAAZ,CAAuBC,OAAvB,CAA+BC,IAA/B,CAAoCG,QAApC,CAA6C,cAA7C,IACIC,SADJ,GAEInC,SAAS,CAACoC,OANG,CAAZ,CAOLrB,IAPK,CAAP;AAQD;;AAED,WAAOiB,UAAU,CAACjB,IAAD,CAAjB;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACE,WAASiB,UAAT,CAAoBjB,IAApB,EAA0B;AACxB,WAAOJ,OAAO,CAAC0B,OAAR,CAAgBjC,UAAhB,EAA4BF,EAA5B,EAAgCU,GAAhC,EAAqCG,IAArC,CAAP;AACD;AACF;AAED;;;AACA,SAASL,IAAT,CAAcC,OAAd,EAAuB;AACrBA,EAAAA,OAAO,CAACD,IAAR,CAAaT,KAAK,CAACG,UAAnB;AACD","sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Exiter} Exiter\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownSpace} from 'micromark-util-character'\nimport {codes} from 'micromark-util-symbol/codes.js'\nimport {constants} from 'micromark-util-symbol/constants.js'\nimport {types} from 'micromark-util-symbol/types.js'\nimport {ok as assert} from 'uvu/assert'\n\n/** @type {Construct} */\nexport const blockQuote = {\n  name: 'blockQuote',\n  tokenize: tokenizeBlockQuoteStart,\n  continuation: {tokenize: tokenizeBlockQuoteContinuation},\n  exit\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeBlockQuoteStart(effects, ok, nok) {\n  const self = this\n\n  return start\n\n  /**\n   * Start of block quote.\n   *\n   * ```markdown\n   * > | > a\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    if (code === codes.greaterThan) {\n      const state = self.containerState\n\n      assert(state, 'expected `containerState` to be defined in container')\n\n      if (!state.open) {\n        effects.enter(types.blockQuote, {_container: true})\n        state.open = true\n      }\n\n      effects.enter(types.blockQuotePrefix)\n      effects.enter(types.blockQuoteMarker)\n      effects.consume(code)\n      effects.exit(types.blockQuoteMarker)\n      return after\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * After `>`, before optional whitespace.\n   *\n   * ```markdown\n   * > | > a\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    if (markdownSpace(code)) {\n      effects.enter(types.blockQuotePrefixWhitespace)\n      effects.consume(code)\n      effects.exit(types.blockQuotePrefixWhitespace)\n      effects.exit(types.blockQuotePrefix)\n      return ok\n    }\n\n    effects.exit(types.blockQuotePrefix)\n    return ok(code)\n  }\n}\n\n/**\n * Start of block quote continuation.\n *\n * ```markdown\n *   | > a\n * > | > b\n *     ^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeBlockQuoteContinuation(effects, ok, nok) {\n  const self = this\n\n  return contStart\n\n  /**\n   * Start of block quote continuation.\n   *\n   * Also used to parse the first block quote opening.\n   *\n   * ```markdown\n   *   | > a\n   * > | > b\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function contStart(code) {\n    if (markdownSpace(code)) {\n      // Always populated by defaults.\n      assert(\n        self.parser.constructs.disable.null,\n        'expected `disable.null` to be populated'\n      )\n\n      return factorySpace(\n        effects,\n        contBefore,\n        types.linePrefix,\n        self.parser.constructs.disable.null.includes('codeIndented')\n          ? undefined\n          : constants.tabSize\n      )(code)\n    }\n\n    return contBefore(code)\n  }\n\n  /**\n   * At `>`, after optional whitespace.\n   *\n   * Also used to parse the first block quote opening.\n   *\n   * ```markdown\n   *   | > a\n   * > | > b\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function contBefore(code) {\n    return effects.attempt(blockQuote, ok, nok)(code)\n  }\n}\n\n/** @type {Exiter} */\nfunction exit(effects) {\n  effects.exit(types.blockQuote)\n}\n"]},"metadata":{},"sourceType":"module"}
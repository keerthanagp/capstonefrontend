{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Previous} Previous\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\nimport { markdownLineEnding } from 'micromark-util-character';\nimport { codes } from 'micromark-util-symbol/codes.js';\nimport { types } from 'micromark-util-symbol/types.js';\nimport { ok as assert } from 'uvu/assert';\n/** @type {Construct} */\n\nexport const codeText = {\n  name: 'codeText',\n  tokenize: tokenizeCodeText,\n  resolve: resolveCodeText,\n  previous\n}; // To do: next major: don’t resolve, like `markdown-rs`.\n\n/** @type {Resolver} */\n\nfunction resolveCodeText(events) {\n  let tailExitIndex = events.length - 4;\n  let headEnterIndex = 3;\n  /** @type {number} */\n\n  let index;\n  /** @type {number | undefined} */\n\n  let enter; // If we start and end with an EOL or a space.\n\n  if ((events[headEnterIndex][1].type === types.lineEnding || events[headEnterIndex][1].type === 'space') && (events[tailExitIndex][1].type === types.lineEnding || events[tailExitIndex][1].type === 'space')) {\n    index = headEnterIndex; // And we have data.\n\n    while (++index < tailExitIndex) {\n      if (events[index][1].type === types.codeTextData) {\n        // Then we have padding.\n        events[headEnterIndex][1].type = types.codeTextPadding;\n        events[tailExitIndex][1].type = types.codeTextPadding;\n        headEnterIndex += 2;\n        tailExitIndex -= 2;\n        break;\n      }\n    }\n  } // Merge adjacent spaces and data.\n\n\n  index = headEnterIndex - 1;\n  tailExitIndex++;\n\n  while (++index <= tailExitIndex) {\n    if (enter === undefined) {\n      if (index !== tailExitIndex && events[index][1].type !== types.lineEnding) {\n        enter = index;\n      }\n    } else if (index === tailExitIndex || events[index][1].type === types.lineEnding) {\n      events[enter][1].type = types.codeTextData;\n\n      if (index !== enter + 2) {\n        events[enter][1].end = events[index - 1][1].end;\n        events.splice(enter + 2, index - enter - 2);\n        tailExitIndex -= index - enter - 2;\n        index = enter + 2;\n      }\n\n      enter = undefined;\n    }\n  }\n\n  return events;\n}\n/**\n * @this {TokenizeContext}\n * @type {Previous}\n */\n\n\nfunction previous(code) {\n  // If there is a previous code, there will always be a tail.\n  return code !== codes.graveAccent || this.events[this.events.length - 1][1].type === types.characterEscape;\n}\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\n\n\nfunction tokenizeCodeText(effects, ok, nok) {\n  const self = this;\n  let sizeOpen = 0;\n  /** @type {number} */\n\n  let size;\n  /** @type {Token} */\n\n  let token;\n  return start;\n  /**\n   * Start of code (text).\n   *\n   * ```markdown\n   * > | `a`\n   *     ^\n   * > | \\`a`\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n\n  function start(code) {\n    assert(code === codes.graveAccent, 'expected `` ` ``');\n    assert(previous.call(self, self.previous), 'expected correct previous');\n    effects.enter(types.codeText);\n    effects.enter(types.codeTextSequence);\n    return sequenceOpen(code);\n  }\n  /**\n   * In opening sequence.\n   *\n   * ```markdown\n   * > | `a`\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function sequenceOpen(code) {\n    if (code === codes.graveAccent) {\n      effects.consume(code);\n      sizeOpen++;\n      return sequenceOpen;\n    }\n\n    effects.exit(types.codeTextSequence);\n    return between(code);\n  }\n  /**\n   * Between something and something else.\n   *\n   * ```markdown\n   * > | `a`\n   *      ^^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function between(code) {\n    // EOF.\n    if (code === codes.eof) {\n      return nok(code);\n    } // To do: next major: don’t do spaces in resolve, but when compiling,\n    // like `markdown-rs`.\n    // Tabs don’t work, and virtual spaces don’t make sense.\n\n\n    if (code === codes.space) {\n      effects.enter('space');\n      effects.consume(code);\n      effects.exit('space');\n      return between;\n    } // Closing fence? Could also be data.\n\n\n    if (code === codes.graveAccent) {\n      token = effects.enter(types.codeTextSequence);\n      size = 0;\n      return sequenceClose(code);\n    }\n\n    if (markdownLineEnding(code)) {\n      effects.enter(types.lineEnding);\n      effects.consume(code);\n      effects.exit(types.lineEnding);\n      return between;\n    } // Data.\n\n\n    effects.enter(types.codeTextData);\n    return data(code);\n  }\n  /**\n   * In data.\n   *\n   * ```markdown\n   * > | `a`\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function data(code) {\n    if (code === codes.eof || code === codes.space || code === codes.graveAccent || markdownLineEnding(code)) {\n      effects.exit(types.codeTextData);\n      return between(code);\n    }\n\n    effects.consume(code);\n    return data;\n  }\n  /**\n   * In closing sequence.\n   *\n   * ```markdown\n   * > | `a`\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function sequenceClose(code) {\n    // More.\n    if (code === codes.graveAccent) {\n      effects.consume(code);\n      size++;\n      return sequenceClose;\n    } // Done!\n\n\n    if (size === sizeOpen) {\n      effects.exit(types.codeTextSequence);\n      effects.exit(types.codeText);\n      return ok(code);\n    } // More or less accents: mark as data.\n\n\n    token.type = types.codeTextData;\n    return data(code);\n  }\n}","map":{"version":3,"sources":["D:/com lab/react/keerthana/auth2/AuthInMern/client/node_modules/micromark-core-commonmark/dev/lib/code-text.js"],"names":["markdownLineEnding","codes","types","ok","assert","codeText","name","tokenize","tokenizeCodeText","resolve","resolveCodeText","previous","events","tailExitIndex","length","headEnterIndex","index","enter","type","lineEnding","codeTextData","codeTextPadding","undefined","end","splice","code","graveAccent","characterEscape","effects","nok","self","sizeOpen","size","token","start","call","codeTextSequence","sequenceOpen","consume","exit","between","eof","space","sequenceClose","data"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Previous} Previous\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {markdownLineEnding} from 'micromark-util-character'\nimport {codes} from 'micromark-util-symbol/codes.js'\nimport {types} from 'micromark-util-symbol/types.js'\nimport {ok as assert} from 'uvu/assert'\n\n/** @type {Construct} */\nexport const codeText = {\n  name: 'codeText',\n  tokenize: tokenizeCodeText,\n  resolve: resolveCodeText,\n  previous\n}\n\n// To do: next major: don’t resolve, like `markdown-rs`.\n/** @type {Resolver} */\nfunction resolveCodeText(events) {\n  let tailExitIndex = events.length - 4\n  let headEnterIndex = 3\n  /** @type {number} */\n  let index\n  /** @type {number | undefined} */\n  let enter\n\n  // If we start and end with an EOL or a space.\n  if (\n    (events[headEnterIndex][1].type === types.lineEnding ||\n      events[headEnterIndex][1].type === 'space') &&\n    (events[tailExitIndex][1].type === types.lineEnding ||\n      events[tailExitIndex][1].type === 'space')\n  ) {\n    index = headEnterIndex\n\n    // And we have data.\n    while (++index < tailExitIndex) {\n      if (events[index][1].type === types.codeTextData) {\n        // Then we have padding.\n        events[headEnterIndex][1].type = types.codeTextPadding\n        events[tailExitIndex][1].type = types.codeTextPadding\n        headEnterIndex += 2\n        tailExitIndex -= 2\n        break\n      }\n    }\n  }\n\n  // Merge adjacent spaces and data.\n  index = headEnterIndex - 1\n  tailExitIndex++\n\n  while (++index <= tailExitIndex) {\n    if (enter === undefined) {\n      if (\n        index !== tailExitIndex &&\n        events[index][1].type !== types.lineEnding\n      ) {\n        enter = index\n      }\n    } else if (\n      index === tailExitIndex ||\n      events[index][1].type === types.lineEnding\n    ) {\n      events[enter][1].type = types.codeTextData\n\n      if (index !== enter + 2) {\n        events[enter][1].end = events[index - 1][1].end\n        events.splice(enter + 2, index - enter - 2)\n        tailExitIndex -= index - enter - 2\n        index = enter + 2\n      }\n\n      enter = undefined\n    }\n  }\n\n  return events\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Previous}\n */\nfunction previous(code) {\n  // If there is a previous code, there will always be a tail.\n  return (\n    code !== codes.graveAccent ||\n    this.events[this.events.length - 1][1].type === types.characterEscape\n  )\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeCodeText(effects, ok, nok) {\n  const self = this\n  let sizeOpen = 0\n  /** @type {number} */\n  let size\n  /** @type {Token} */\n  let token\n\n  return start\n\n  /**\n   * Start of code (text).\n   *\n   * ```markdown\n   * > | `a`\n   *     ^\n   * > | \\`a`\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    assert(code === codes.graveAccent, 'expected `` ` ``')\n    assert(previous.call(self, self.previous), 'expected correct previous')\n    effects.enter(types.codeText)\n    effects.enter(types.codeTextSequence)\n    return sequenceOpen(code)\n  }\n\n  /**\n   * In opening sequence.\n   *\n   * ```markdown\n   * > | `a`\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function sequenceOpen(code) {\n    if (code === codes.graveAccent) {\n      effects.consume(code)\n      sizeOpen++\n      return sequenceOpen\n    }\n\n    effects.exit(types.codeTextSequence)\n    return between(code)\n  }\n\n  /**\n   * Between something and something else.\n   *\n   * ```markdown\n   * > | `a`\n   *      ^^\n   * ```\n   *\n   * @type {State}\n   */\n  function between(code) {\n    // EOF.\n    if (code === codes.eof) {\n      return nok(code)\n    }\n\n    // To do: next major: don’t do spaces in resolve, but when compiling,\n    // like `markdown-rs`.\n    // Tabs don’t work, and virtual spaces don’t make sense.\n    if (code === codes.space) {\n      effects.enter('space')\n      effects.consume(code)\n      effects.exit('space')\n      return between\n    }\n\n    // Closing fence? Could also be data.\n    if (code === codes.graveAccent) {\n      token = effects.enter(types.codeTextSequence)\n      size = 0\n      return sequenceClose(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      effects.enter(types.lineEnding)\n      effects.consume(code)\n      effects.exit(types.lineEnding)\n      return between\n    }\n\n    // Data.\n    effects.enter(types.codeTextData)\n    return data(code)\n  }\n\n  /**\n   * In data.\n   *\n   * ```markdown\n   * > | `a`\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function data(code) {\n    if (\n      code === codes.eof ||\n      code === codes.space ||\n      code === codes.graveAccent ||\n      markdownLineEnding(code)\n    ) {\n      effects.exit(types.codeTextData)\n      return between(code)\n    }\n\n    effects.consume(code)\n    return data\n  }\n\n  /**\n   * In closing sequence.\n   *\n   * ```markdown\n   * > | `a`\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function sequenceClose(code) {\n    // More.\n    if (code === codes.graveAccent) {\n      effects.consume(code)\n      size++\n      return sequenceClose\n    }\n\n    // Done!\n    if (size === sizeOpen) {\n      effects.exit(types.codeTextSequence)\n      effects.exit(types.codeText)\n      return ok(code)\n    }\n\n    // More or less accents: mark as data.\n    token.type = types.codeTextData\n    return data(code)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}
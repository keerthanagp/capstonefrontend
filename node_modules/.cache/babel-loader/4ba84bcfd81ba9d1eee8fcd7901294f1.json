{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEnding, markdownSpace } from 'micromark-util-character';\nimport { codes } from 'micromark-util-symbol/codes.js';\nimport { types } from 'micromark-util-symbol/types.js';\nimport { ok as assert } from 'uvu/assert';\n/** @type {Construct} */\n\nexport const setextUnderline = {\n  name: 'setextUnderline',\n  tokenize: tokenizeSetextUnderline,\n  resolveTo: resolveToSetextUnderline\n};\n/** @type {Resolver} */\n\nfunction resolveToSetextUnderline(events, context) {\n  // To do: resolve like `markdown-rs`.\n  let index = events.length;\n  /** @type {number | undefined} */\n\n  let content;\n  /** @type {number | undefined} */\n\n  let text;\n  /** @type {number | undefined} */\n\n  let definition; // Find the opening of the content.\n  // It’ll always exist: we don’t tokenize if it isn’t there.\n\n  while (index--) {\n    if (events[index][0] === 'enter') {\n      if (events[index][1].type === types.content) {\n        content = index;\n        break;\n      }\n\n      if (events[index][1].type === types.paragraph) {\n        text = index;\n      }\n    } // Exit\n    else {\n      if (events[index][1].type === types.content) {\n        // Remove the content end (if needed we’ll add it later)\n        events.splice(index, 1);\n      }\n\n      if (!definition && events[index][1].type === types.definition) {\n        definition = index;\n      }\n    }\n  }\n\n  assert(text !== undefined, 'expected a `text` index to be found');\n  assert(content !== undefined, 'expected a `text` index to be found');\n  const heading = {\n    type: types.setextHeading,\n    start: Object.assign({}, events[text][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  }; // Change the paragraph to setext heading text.\n\n  events[text][1].type = types.setextHeadingText; // If we have definitions in the content, we’ll keep on having content,\n  // but we need move it.\n\n  if (definition) {\n    events.splice(text, 0, ['enter', heading, context]);\n    events.splice(definition + 1, 0, ['exit', events[content][1], context]);\n    events[content][1].end = Object.assign({}, events[definition][1].end);\n  } else {\n    events[content][1] = heading;\n  } // Add the heading exit at the end.\n\n\n  events.push(['exit', heading, context]);\n  return events;\n}\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\n\n\nfunction tokenizeSetextUnderline(effects, ok, nok) {\n  const self = this;\n  /** @type {NonNullable<Code>} */\n\n  let marker;\n  return start;\n  /**\n   * At start of heading (setext) underline.\n   *\n   * ```markdown\n   *   | aa\n   * > | ==\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n\n  function start(code) {\n    let index = self.events.length;\n    /** @type {boolean | undefined} */\n\n    let paragraph;\n    assert(code === codes.dash || code === codes.equalsTo, 'expected `=` or `-`'); // Find an opening.\n\n    while (index--) {\n      // Skip enter/exit of line ending, line prefix, and content.\n      // We can now either have a definition or a paragraph.\n      if (self.events[index][1].type !== types.lineEnding && self.events[index][1].type !== types.linePrefix && self.events[index][1].type !== types.content) {\n        paragraph = self.events[index][1].type === types.paragraph;\n        break;\n      }\n    } // To do: handle lazy/pierce like `markdown-rs`.\n    // To do: parse indent like `markdown-rs`.\n\n\n    if (!self.parser.lazy[self.now().line] && (self.interrupt || paragraph)) {\n      effects.enter(types.setextHeadingLine);\n      marker = code;\n      return before(code);\n    }\n\n    return nok(code);\n  }\n  /**\n   * After optional whitespace, at `-` or `=`.\n   *\n   * ```markdown\n   *   | aa\n   * > | ==\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function before(code) {\n    effects.enter(types.setextHeadingLineSequence);\n    return inside(code);\n  }\n  /**\n   * In sequence.\n   *\n   * ```markdown\n   *   | aa\n   * > | ==\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function inside(code) {\n    if (code === marker) {\n      effects.consume(code);\n      return inside;\n    }\n\n    effects.exit(types.setextHeadingLineSequence);\n    return markdownSpace(code) ? factorySpace(effects, after, types.lineSuffix)(code) : after(code);\n  }\n  /**\n   * After sequence, after optional whitespace.\n   *\n   * ```markdown\n   *   | aa\n   * > | ==\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function after(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.setextHeadingLine);\n      return ok(code);\n    }\n\n    return nok(code);\n  }\n}","map":{"version":3,"sources":["D:/com lab/react/keerthana/auth2/AuthInMern/client/node_modules/micromark-core-commonmark/dev/lib/setext-underline.js"],"names":["factorySpace","markdownLineEnding","markdownSpace","codes","types","ok","assert","setextUnderline","name","tokenize","tokenizeSetextUnderline","resolveTo","resolveToSetextUnderline","events","context","index","length","content","text","definition","type","paragraph","splice","undefined","heading","setextHeading","start","Object","assign","end","setextHeadingText","push","effects","nok","self","marker","code","dash","equalsTo","lineEnding","linePrefix","parser","lazy","now","line","interrupt","enter","setextHeadingLine","before","setextHeadingLineSequence","inside","consume","exit","after","lineSuffix","eof"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding, markdownSpace} from 'micromark-util-character'\nimport {codes} from 'micromark-util-symbol/codes.js'\nimport {types} from 'micromark-util-symbol/types.js'\nimport {ok as assert} from 'uvu/assert'\n\n/** @type {Construct} */\nexport const setextUnderline = {\n  name: 'setextUnderline',\n  tokenize: tokenizeSetextUnderline,\n  resolveTo: resolveToSetextUnderline\n}\n\n/** @type {Resolver} */\nfunction resolveToSetextUnderline(events, context) {\n  // To do: resolve like `markdown-rs`.\n  let index = events.length\n  /** @type {number | undefined} */\n  let content\n  /** @type {number | undefined} */\n  let text\n  /** @type {number | undefined} */\n  let definition\n\n  // Find the opening of the content.\n  // It’ll always exist: we don’t tokenize if it isn’t there.\n  while (index--) {\n    if (events[index][0] === 'enter') {\n      if (events[index][1].type === types.content) {\n        content = index\n        break\n      }\n\n      if (events[index][1].type === types.paragraph) {\n        text = index\n      }\n    }\n    // Exit\n    else {\n      if (events[index][1].type === types.content) {\n        // Remove the content end (if needed we’ll add it later)\n        events.splice(index, 1)\n      }\n\n      if (!definition && events[index][1].type === types.definition) {\n        definition = index\n      }\n    }\n  }\n\n  assert(text !== undefined, 'expected a `text` index to be found')\n  assert(content !== undefined, 'expected a `text` index to be found')\n\n  const heading = {\n    type: types.setextHeading,\n    start: Object.assign({}, events[text][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  }\n\n  // Change the paragraph to setext heading text.\n  events[text][1].type = types.setextHeadingText\n\n  // If we have definitions in the content, we’ll keep on having content,\n  // but we need move it.\n  if (definition) {\n    events.splice(text, 0, ['enter', heading, context])\n    events.splice(definition + 1, 0, ['exit', events[content][1], context])\n    events[content][1].end = Object.assign({}, events[definition][1].end)\n  } else {\n    events[content][1] = heading\n  }\n\n  // Add the heading exit at the end.\n  events.push(['exit', heading, context])\n\n  return events\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeSetextUnderline(effects, ok, nok) {\n  const self = this\n  /** @type {NonNullable<Code>} */\n  let marker\n\n  return start\n\n  /**\n   * At start of heading (setext) underline.\n   *\n   * ```markdown\n   *   | aa\n   * > | ==\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    let index = self.events.length\n    /** @type {boolean | undefined} */\n    let paragraph\n\n    assert(\n      code === codes.dash || code === codes.equalsTo,\n      'expected `=` or `-`'\n    )\n\n    // Find an opening.\n    while (index--) {\n      // Skip enter/exit of line ending, line prefix, and content.\n      // We can now either have a definition or a paragraph.\n      if (\n        self.events[index][1].type !== types.lineEnding &&\n        self.events[index][1].type !== types.linePrefix &&\n        self.events[index][1].type !== types.content\n      ) {\n        paragraph = self.events[index][1].type === types.paragraph\n        break\n      }\n    }\n\n    // To do: handle lazy/pierce like `markdown-rs`.\n    // To do: parse indent like `markdown-rs`.\n    if (!self.parser.lazy[self.now().line] && (self.interrupt || paragraph)) {\n      effects.enter(types.setextHeadingLine)\n      marker = code\n      return before(code)\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * After optional whitespace, at `-` or `=`.\n   *\n   * ```markdown\n   *   | aa\n   * > | ==\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function before(code) {\n    effects.enter(types.setextHeadingLineSequence)\n    return inside(code)\n  }\n\n  /**\n   * In sequence.\n   *\n   * ```markdown\n   *   | aa\n   * > | ==\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function inside(code) {\n    if (code === marker) {\n      effects.consume(code)\n      return inside\n    }\n\n    effects.exit(types.setextHeadingLineSequence)\n\n    return markdownSpace(code)\n      ? factorySpace(effects, after, types.lineSuffix)(code)\n      : after(code)\n  }\n\n  /**\n   * After sequence, after optional whitespace.\n   *\n   * ```markdown\n   *   | aa\n   * > | ==\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.setextHeadingLine)\n      return ok(code)\n    }\n\n    return nok(code)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEnding, markdownLineEndingOrSpace, markdownSpace } from 'micromark-util-character';\nimport { splice } from 'micromark-util-chunked';\nimport { codes } from 'micromark-util-symbol/codes.js';\nimport { constants } from 'micromark-util-symbol/constants.js';\nimport { types } from 'micromark-util-symbol/types.js';\nimport { ok as assert } from 'uvu/assert';\n/** @type {Construct} */\n\nexport const headingAtx = {\n  name: 'headingAtx',\n  tokenize: tokenizeHeadingAtx,\n  resolve: resolveHeadingAtx\n};\n/** @type {Resolver} */\n\nfunction resolveHeadingAtx(events, context) {\n  let contentEnd = events.length - 2;\n  let contentStart = 3;\n  /** @type {Token} */\n\n  let content;\n  /** @type {Token} */\n\n  let text; // Prefix whitespace, part of the opening.\n\n  if (events[contentStart][1].type === types.whitespace) {\n    contentStart += 2;\n  } // Suffix whitespace, part of the closing.\n\n\n  if (contentEnd - 2 > contentStart && events[contentEnd][1].type === types.whitespace) {\n    contentEnd -= 2;\n  }\n\n  if (events[contentEnd][1].type === types.atxHeadingSequence && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === types.whitespace)) {\n    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;\n  }\n\n  if (contentEnd > contentStart) {\n    content = {\n      type: types.atxHeadingText,\n      start: events[contentStart][1].start,\n      end: events[contentEnd][1].end\n    };\n    text = {\n      type: types.chunkText,\n      start: events[contentStart][1].start,\n      end: events[contentEnd][1].end,\n      contentType: constants.contentTypeText\n    };\n    splice(events, contentStart, contentEnd - contentStart + 1, [['enter', content, context], ['enter', text, context], ['exit', text, context], ['exit', content, context]]);\n  }\n\n  return events;\n}\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\n\n\nfunction tokenizeHeadingAtx(effects, ok, nok) {\n  let size = 0;\n  return start;\n  /**\n   * Start of a heading (atx).\n   *\n   * ```markdown\n   * > | ## aa\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n\n  function start(code) {\n    // To do: parse indent like `markdown-rs`.\n    effects.enter(types.atxHeading);\n    return before(code);\n  }\n  /**\n   * After optional whitespace, at `#`.\n   *\n   * ```markdown\n   * > | ## aa\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function before(code) {\n    assert(code === codes.numberSign, 'expected `#`');\n    effects.enter(types.atxHeadingSequence);\n    return sequenceOpen(code);\n  }\n  /**\n   * In opening sequence.\n   *\n   * ```markdown\n   * > | ## aa\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function sequenceOpen(code) {\n    if (code === codes.numberSign && size++ < constants.atxHeadingOpeningFenceSizeMax) {\n      effects.consume(code);\n      return sequenceOpen;\n    } // Always at least one `#`.\n\n\n    if (code === codes.eof || markdownLineEndingOrSpace(code)) {\n      effects.exit(types.atxHeadingSequence);\n      return atBreak(code);\n    }\n\n    return nok(code);\n  }\n  /**\n   * After something, before something else.\n   *\n   * ```markdown\n   * > | ## aa\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function atBreak(code) {\n    if (code === codes.numberSign) {\n      effects.enter(types.atxHeadingSequence);\n      return sequenceFurther(code);\n    }\n\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.atxHeading); // To do: interrupt like `markdown-rs`.\n      // // Feel free to interrupt.\n      // tokenizer.interrupt = false\n\n      return ok(code);\n    }\n\n    if (markdownSpace(code)) {\n      return factorySpace(effects, atBreak, types.whitespace)(code);\n    } // To do: generate `data` tokens, add the `text` token later.\n    // Needs edit map, see: `markdown.rs`.\n\n\n    effects.enter(types.atxHeadingText);\n    return data(code);\n  }\n  /**\n   * In further sequence (after whitespace).\n   *\n   * Could be normal “visible” hashes in the heading or a final sequence.\n   *\n   * ```markdown\n   * > | ## aa ##\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function sequenceFurther(code) {\n    if (code === codes.numberSign) {\n      effects.consume(code);\n      return sequenceFurther;\n    }\n\n    effects.exit(types.atxHeadingSequence);\n    return atBreak(code);\n  }\n  /**\n   * In text.\n   *\n   * ```markdown\n   * > | ## aa\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function data(code) {\n    if (code === codes.eof || code === codes.numberSign || markdownLineEndingOrSpace(code)) {\n      effects.exit(types.atxHeadingText);\n      return atBreak(code);\n    }\n\n    effects.consume(code);\n    return data;\n  }\n}","map":{"version":3,"sources":["D:/com lab/react/keerthana/auth2/AuthInMern/client/node_modules/micromark-core-commonmark/dev/lib/heading-atx.js"],"names":["factorySpace","markdownLineEnding","markdownLineEndingOrSpace","markdownSpace","splice","codes","constants","types","ok","assert","headingAtx","name","tokenize","tokenizeHeadingAtx","resolve","resolveHeadingAtx","events","context","contentEnd","length","contentStart","content","text","type","whitespace","atxHeadingSequence","atxHeadingText","start","end","chunkText","contentType","contentTypeText","effects","nok","size","code","enter","atxHeading","before","numberSign","sequenceOpen","atxHeadingOpeningFenceSizeMax","consume","eof","exit","atBreak","sequenceFurther","data"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {\n  markdownLineEnding,\n  markdownLineEndingOrSpace,\n  markdownSpace\n} from 'micromark-util-character'\nimport {splice} from 'micromark-util-chunked'\nimport {codes} from 'micromark-util-symbol/codes.js'\nimport {constants} from 'micromark-util-symbol/constants.js'\nimport {types} from 'micromark-util-symbol/types.js'\nimport {ok as assert} from 'uvu/assert'\n\n/** @type {Construct} */\nexport const headingAtx = {\n  name: 'headingAtx',\n  tokenize: tokenizeHeadingAtx,\n  resolve: resolveHeadingAtx\n}\n\n/** @type {Resolver} */\nfunction resolveHeadingAtx(events, context) {\n  let contentEnd = events.length - 2\n  let contentStart = 3\n  /** @type {Token} */\n  let content\n  /** @type {Token} */\n  let text\n\n  // Prefix whitespace, part of the opening.\n  if (events[contentStart][1].type === types.whitespace) {\n    contentStart += 2\n  }\n\n  // Suffix whitespace, part of the closing.\n  if (\n    contentEnd - 2 > contentStart &&\n    events[contentEnd][1].type === types.whitespace\n  ) {\n    contentEnd -= 2\n  }\n\n  if (\n    events[contentEnd][1].type === types.atxHeadingSequence &&\n    (contentStart === contentEnd - 1 ||\n      (contentEnd - 4 > contentStart &&\n        events[contentEnd - 2][1].type === types.whitespace))\n  ) {\n    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4\n  }\n\n  if (contentEnd > contentStart) {\n    content = {\n      type: types.atxHeadingText,\n      start: events[contentStart][1].start,\n      end: events[contentEnd][1].end\n    }\n    text = {\n      type: types.chunkText,\n      start: events[contentStart][1].start,\n      end: events[contentEnd][1].end,\n      contentType: constants.contentTypeText\n    }\n\n    splice(events, contentStart, contentEnd - contentStart + 1, [\n      ['enter', content, context],\n      ['enter', text, context],\n      ['exit', text, context],\n      ['exit', content, context]\n    ])\n  }\n\n  return events\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeHeadingAtx(effects, ok, nok) {\n  let size = 0\n\n  return start\n\n  /**\n   * Start of a heading (atx).\n   *\n   * ```markdown\n   * > | ## aa\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    // To do: parse indent like `markdown-rs`.\n    effects.enter(types.atxHeading)\n    return before(code)\n  }\n\n  /**\n   * After optional whitespace, at `#`.\n   *\n   * ```markdown\n   * > | ## aa\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function before(code) {\n    assert(code === codes.numberSign, 'expected `#`')\n    effects.enter(types.atxHeadingSequence)\n    return sequenceOpen(code)\n  }\n\n  /**\n   * In opening sequence.\n   *\n   * ```markdown\n   * > | ## aa\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function sequenceOpen(code) {\n    if (\n      code === codes.numberSign &&\n      size++ < constants.atxHeadingOpeningFenceSizeMax\n    ) {\n      effects.consume(code)\n      return sequenceOpen\n    }\n\n    // Always at least one `#`.\n    if (code === codes.eof || markdownLineEndingOrSpace(code)) {\n      effects.exit(types.atxHeadingSequence)\n      return atBreak(code)\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * After something, before something else.\n   *\n   * ```markdown\n   * > | ## aa\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function atBreak(code) {\n    if (code === codes.numberSign) {\n      effects.enter(types.atxHeadingSequence)\n      return sequenceFurther(code)\n    }\n\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.atxHeading)\n      // To do: interrupt like `markdown-rs`.\n      // // Feel free to interrupt.\n      // tokenizer.interrupt = false\n      return ok(code)\n    }\n\n    if (markdownSpace(code)) {\n      return factorySpace(effects, atBreak, types.whitespace)(code)\n    }\n\n    // To do: generate `data` tokens, add the `text` token later.\n    // Needs edit map, see: `markdown.rs`.\n    effects.enter(types.atxHeadingText)\n    return data(code)\n  }\n\n  /**\n   * In further sequence (after whitespace).\n   *\n   * Could be normal “visible” hashes in the heading or a final sequence.\n   *\n   * ```markdown\n   * > | ## aa ##\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function sequenceFurther(code) {\n    if (code === codes.numberSign) {\n      effects.consume(code)\n      return sequenceFurther\n    }\n\n    effects.exit(types.atxHeadingSequence)\n    return atBreak(code)\n  }\n\n  /**\n   * In text.\n   *\n   * ```markdown\n   * > | ## aa\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function data(code) {\n    if (\n      code === codes.eof ||\n      code === codes.numberSign ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      effects.exit(types.atxHeadingText)\n      return atBreak(code)\n    }\n\n    effects.consume(code)\n    return data\n  }\n}\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\nimport { factoryDestination } from 'micromark-factory-destination';\nimport { factoryLabel } from 'micromark-factory-label';\nimport { factoryTitle } from 'micromark-factory-title';\nimport { factoryWhitespace } from 'micromark-factory-whitespace';\nimport { markdownLineEndingOrSpace } from 'micromark-util-character';\nimport { push, splice } from 'micromark-util-chunked';\nimport { normalizeIdentifier } from 'micromark-util-normalize-identifier';\nimport { resolveAll } from 'micromark-util-resolve-all';\nimport { codes } from 'micromark-util-symbol/codes.js';\nimport { constants } from 'micromark-util-symbol/constants.js';\nimport { types } from 'micromark-util-symbol/types.js';\nimport { ok as assert } from 'uvu/assert';\n/** @type {Construct} */\n\nexport const labelEnd = {\n  name: 'labelEnd',\n  tokenize: tokenizeLabelEnd,\n  resolveTo: resolveToLabelEnd,\n  resolveAll: resolveAllLabelEnd\n};\n/** @type {Construct} */\n\nconst resourceConstruct = {\n  tokenize: tokenizeResource\n};\n/** @type {Construct} */\n\nconst referenceFullConstruct = {\n  tokenize: tokenizeReferenceFull\n};\n/** @type {Construct} */\n\nconst referenceCollapsedConstruct = {\n  tokenize: tokenizeReferenceCollapsed\n};\n/** @type {Resolver} */\n\nfunction resolveAllLabelEnd(events) {\n  let index = -1;\n\n  while (++index < events.length) {\n    const token = events[index][1];\n\n    if (token.type === types.labelImage || token.type === types.labelLink || token.type === types.labelEnd) {\n      // Remove the marker.\n      events.splice(index + 1, token.type === types.labelImage ? 4 : 2);\n      token.type = types.data;\n      index++;\n    }\n  }\n\n  return events;\n}\n/** @type {Resolver} */\n\n\nfunction resolveToLabelEnd(events, context) {\n  let index = events.length;\n  let offset = 0;\n  /** @type {Token} */\n\n  let token;\n  /** @type {number | undefined} */\n\n  let open;\n  /** @type {number | undefined} */\n\n  let close;\n  /** @type {Array<Event>} */\n\n  let media; // Find an opening.\n\n  while (index--) {\n    token = events[index][1];\n\n    if (open) {\n      // If we see another link, or inactive link label, weâ€™ve been here before.\n      if (token.type === types.link || token.type === types.labelLink && token._inactive) {\n        break;\n      } // Mark other link openings as inactive, as we canâ€™t have links in\n      // links.\n\n\n      if (events[index][0] === 'enter' && token.type === types.labelLink) {\n        token._inactive = true;\n      }\n    } else if (close) {\n      if (events[index][0] === 'enter' && (token.type === types.labelImage || token.type === types.labelLink) && !token._balanced) {\n        open = index;\n\n        if (token.type !== types.labelLink) {\n          offset = 2;\n          break;\n        }\n      }\n    } else if (token.type === types.labelEnd) {\n      close = index;\n    }\n  }\n\n  assert(open !== undefined, '`open` is supposed to be found');\n  assert(close !== undefined, '`close` is supposed to be found');\n  const group = {\n    type: events[open][1].type === types.labelLink ? types.link : types.image,\n    start: Object.assign({}, events[open][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  };\n  const label = {\n    type: types.label,\n    start: Object.assign({}, events[open][1].start),\n    end: Object.assign({}, events[close][1].end)\n  };\n  const text = {\n    type: types.labelText,\n    start: Object.assign({}, events[open + offset + 2][1].end),\n    end: Object.assign({}, events[close - 2][1].start)\n  };\n  media = [['enter', group, context], ['enter', label, context]]; // Opening marker.\n\n  media = push(media, events.slice(open + 1, open + offset + 3)); // Text open.\n\n  media = push(media, [['enter', text, context]]); // Always populated by defaults.\n\n  assert(context.parser.constructs.insideSpan.null, 'expected `insideSpan.null` to be populated'); // Between.\n\n  media = push(media, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + offset + 4, close - 3), context)); // Text close, marker close, label close.\n\n  media = push(media, [['exit', text, context], events[close - 2], events[close - 1], ['exit', label, context]]); // Reference, resource, or so.\n\n  media = push(media, events.slice(close + 1)); // Media close.\n\n  media = push(media, [['exit', group, context]]);\n  splice(events, open, events.length, media);\n  return events;\n}\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\n\n\nfunction tokenizeLabelEnd(effects, ok, nok) {\n  const self = this;\n  let index = self.events.length;\n  /** @type {Token} */\n\n  let labelStart;\n  /** @type {boolean} */\n\n  let defined; // Find an opening.\n\n  while (index--) {\n    if ((self.events[index][1].type === types.labelImage || self.events[index][1].type === types.labelLink) && !self.events[index][1]._balanced) {\n      labelStart = self.events[index][1];\n      break;\n    }\n  }\n\n  return start;\n  /**\n   * Start of label end.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *       ^\n   * > | [a][b] c\n   *       ^\n   * > | [a][] b\n   *       ^\n   * > | [a] b\n   * ```\n   *\n   * @type {State}\n   */\n\n  function start(code) {\n    assert(code === codes.rightSquareBracket, 'expected `]`'); // If there is not an okay opening.\n\n    if (!labelStart) {\n      return nok(code);\n    } // If the corresponding label (link) start is marked as inactive,\n    // it means weâ€™d be wrapping a link, like this:\n    //\n    // ```markdown\n    // > | a [b [c](d) e](f) g.\n    //                  ^\n    // ```\n    //\n    // We canâ€™t have that, so itâ€™s just balanced brackets.\n\n\n    if (labelStart._inactive) {\n      return labelEndNok(code);\n    }\n\n    defined = self.parser.defined.includes(normalizeIdentifier(self.sliceSerialize({\n      start: labelStart.end,\n      end: self.now()\n    })));\n    effects.enter(types.labelEnd);\n    effects.enter(types.labelMarker);\n    effects.consume(code);\n    effects.exit(types.labelMarker);\n    effects.exit(types.labelEnd);\n    return after;\n  }\n  /**\n   * After `]`.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *       ^\n   * > | [a][b] c\n   *       ^\n   * > | [a][] b\n   *       ^\n   * > | [a] b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function after(code) {\n    // Note: `markdown-rs` also parses GFM footnotes here, which for us is in\n    // an extension.\n    // Resource (`[asd](fgh)`)?\n    if (code === codes.leftParenthesis) {\n      return effects.attempt(resourceConstruct, labelEndOk, defined ? labelEndOk : labelEndNok)(code);\n    } // Full (`[asd][fgh]`) or collapsed (`[asd][]`) reference?\n\n\n    if (code === codes.leftSquareBracket) {\n      return effects.attempt(referenceFullConstruct, labelEndOk, defined ? referenceNotFull : labelEndNok)(code);\n    } // Shortcut (`[asd]`) reference?\n\n\n    return defined ? labelEndOk(code) : labelEndNok(code);\n  }\n  /**\n   * After `]`, at `[`, but not at a full reference.\n   *\n   * > ðŸ‘‰ **Note**: we only get here if the label is defined.\n   *\n   * ```markdown\n   * > | [a][] b\n   *        ^\n   * > | [a] b\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function referenceNotFull(code) {\n    return effects.attempt(referenceCollapsedConstruct, labelEndOk, labelEndNok)(code);\n  }\n  /**\n   * Done, we found something.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *           ^\n   * > | [a][b] c\n   *           ^\n   * > | [a][] b\n   *          ^\n   * > | [a] b\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function labelEndOk(code) {\n    // Note: `markdown-rs` does a bunch of stuff here.\n    return ok(code);\n  }\n  /**\n   * Done, itâ€™s nothing.\n   *\n   * There was an okay opening, but we didnâ€™t match anything.\n   *\n   * ```markdown\n   * > | [a](b c\n   *        ^\n   * > | [a][b c\n   *        ^\n   * > | [a] b\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function labelEndNok(code) {\n    labelStart._balanced = true;\n    return nok(code);\n  }\n}\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\n\n\nfunction tokenizeResource(effects, ok, nok) {\n  return resourceStart;\n  /**\n   * At a resource.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n\n  function resourceStart(code) {\n    assert(code === codes.leftParenthesis, 'expected left paren');\n    effects.enter(types.resource);\n    effects.enter(types.resourceMarker);\n    effects.consume(code);\n    effects.exit(types.resourceMarker);\n    return resourceBefore;\n  }\n  /**\n   * In resource, after `(`, at optional whitespace.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function resourceBefore(code) {\n    return markdownLineEndingOrSpace(code) ? factoryWhitespace(effects, resourceOpen)(code) : resourceOpen(code);\n  }\n  /**\n   * In resource, after optional whitespace, at `)` or a destination.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function resourceOpen(code) {\n    if (code === codes.rightParenthesis) {\n      return resourceEnd(code);\n    }\n\n    return factoryDestination(effects, resourceDestinationAfter, resourceDestinationMissing, types.resourceDestination, types.resourceDestinationLiteral, types.resourceDestinationLiteralMarker, types.resourceDestinationRaw, types.resourceDestinationString, constants.linkResourceDestinationBalanceMax)(code);\n  }\n  /**\n   * In resource, after destination, at optional whitespace.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function resourceDestinationAfter(code) {\n    return markdownLineEndingOrSpace(code) ? factoryWhitespace(effects, resourceBetween)(code) : resourceEnd(code);\n  }\n  /**\n   * At invalid destination.\n   *\n   * ```markdown\n   * > | [a](<<) b\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function resourceDestinationMissing(code) {\n    return nok(code);\n  }\n  /**\n   * In resource, after destination and whitespace, at `(` or title.\n   *\n   * ```markdown\n   * > | [a](b ) c\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function resourceBetween(code) {\n    if (code === codes.quotationMark || code === codes.apostrophe || code === codes.leftParenthesis) {\n      return factoryTitle(effects, resourceTitleAfter, nok, types.resourceTitle, types.resourceTitleMarker, types.resourceTitleString)(code);\n    }\n\n    return resourceEnd(code);\n  }\n  /**\n   * In resource, after title, at optional whitespace.\n   *\n   * ```markdown\n   * > | [a](b \"c\") d\n   *              ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function resourceTitleAfter(code) {\n    return markdownLineEndingOrSpace(code) ? factoryWhitespace(effects, resourceEnd)(code) : resourceEnd(code);\n  }\n  /**\n   * In resource, at `)`.\n   *\n   * ```markdown\n   * > | [a](b) d\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function resourceEnd(code) {\n    if (code === codes.rightParenthesis) {\n      effects.enter(types.resourceMarker);\n      effects.consume(code);\n      effects.exit(types.resourceMarker);\n      effects.exit(types.resource);\n      return ok;\n    }\n\n    return nok(code);\n  }\n}\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\n\n\nfunction tokenizeReferenceFull(effects, ok, nok) {\n  const self = this;\n  return referenceFull;\n  /**\n   * In a reference (full), at the `[`.\n   *\n   * ```markdown\n   * > | [a][b] d\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n\n  function referenceFull(code) {\n    assert(code === codes.leftSquareBracket, 'expected left bracket');\n    return factoryLabel.call(self, effects, referenceFullAfter, referenceFullMissing, types.reference, types.referenceMarker, types.referenceString)(code);\n  }\n  /**\n   * In a reference (full), after `]`.\n   *\n   * ```markdown\n   * > | [a][b] d\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function referenceFullAfter(code) {\n    return self.parser.defined.includes(normalizeIdentifier(self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1))) ? ok(code) : nok(code);\n  }\n  /**\n   * In reference (full) that was missing.\n   *\n   * ```markdown\n   * > | [a][b d\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function referenceFullMissing(code) {\n    return nok(code);\n  }\n}\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\n\n\nfunction tokenizeReferenceCollapsed(effects, ok, nok) {\n  return referenceCollapsedStart;\n  /**\n   * In reference (collapsed), at `[`.\n   *\n   * > ðŸ‘‰ **Note**: we only get here if the label is defined.\n   *\n   * ```markdown\n   * > | [a][] d\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n\n  function referenceCollapsedStart(code) {\n    // We only attempt a collapsed label if thereâ€™s a `[`.\n    assert(code === codes.leftSquareBracket, 'expected left bracket');\n    effects.enter(types.reference);\n    effects.enter(types.referenceMarker);\n    effects.consume(code);\n    effects.exit(types.referenceMarker);\n    return referenceCollapsedOpen;\n  }\n  /**\n   * In reference (collapsed), at `]`.\n   *\n   * > ðŸ‘‰ **Note**: we only get here if the label is defined.\n   *\n   * ```markdown\n   * > | [a][] d\n   *         ^\n   * ```\n   *\n   *  @type {State}\n   */\n\n\n  function referenceCollapsedOpen(code) {\n    if (code === codes.rightSquareBracket) {\n      effects.enter(types.referenceMarker);\n      effects.consume(code);\n      effects.exit(types.referenceMarker);\n      effects.exit(types.reference);\n      return ok;\n    }\n\n    return nok(code);\n  }\n}","map":{"version":3,"sources":["D:/com lab/react/keerthana/auth2/AuthInMern/client/node_modules/micromark-core-commonmark/dev/lib/label-end.js"],"names":["factoryDestination","factoryLabel","factoryTitle","factoryWhitespace","markdownLineEndingOrSpace","push","splice","normalizeIdentifier","resolveAll","codes","constants","types","ok","assert","labelEnd","name","tokenize","tokenizeLabelEnd","resolveTo","resolveToLabelEnd","resolveAllLabelEnd","resourceConstruct","tokenizeResource","referenceFullConstruct","tokenizeReferenceFull","referenceCollapsedConstruct","tokenizeReferenceCollapsed","events","index","length","token","type","labelImage","labelLink","data","context","offset","open","close","media","link","_inactive","_balanced","undefined","group","image","start","Object","assign","end","label","text","labelText","slice","parser","constructs","insideSpan","null","effects","nok","self","labelStart","defined","code","rightSquareBracket","labelEndNok","includes","sliceSerialize","now","enter","labelMarker","consume","exit","after","leftParenthesis","attempt","labelEndOk","leftSquareBracket","referenceNotFull","resourceStart","resource","resourceMarker","resourceBefore","resourceOpen","rightParenthesis","resourceEnd","resourceDestinationAfter","resourceDestinationMissing","resourceDestination","resourceDestinationLiteral","resourceDestinationLiteralMarker","resourceDestinationRaw","resourceDestinationString","linkResourceDestinationBalanceMax","resourceBetween","quotationMark","apostrophe","resourceTitleAfter","resourceTitle","resourceTitleMarker","resourceTitleString","referenceFull","call","referenceFullAfter","referenceFullMissing","reference","referenceMarker","referenceString","referenceCollapsedStart","referenceCollapsedOpen"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factoryDestination} from 'micromark-factory-destination'\nimport {factoryLabel} from 'micromark-factory-label'\nimport {factoryTitle} from 'micromark-factory-title'\nimport {factoryWhitespace} from 'micromark-factory-whitespace'\nimport {markdownLineEndingOrSpace} from 'micromark-util-character'\nimport {push, splice} from 'micromark-util-chunked'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nimport {resolveAll} from 'micromark-util-resolve-all'\nimport {codes} from 'micromark-util-symbol/codes.js'\nimport {constants} from 'micromark-util-symbol/constants.js'\nimport {types} from 'micromark-util-symbol/types.js'\nimport {ok as assert} from 'uvu/assert'\n\n/** @type {Construct} */\nexport const labelEnd = {\n  name: 'labelEnd',\n  tokenize: tokenizeLabelEnd,\n  resolveTo: resolveToLabelEnd,\n  resolveAll: resolveAllLabelEnd\n}\n\n/** @type {Construct} */\nconst resourceConstruct = {tokenize: tokenizeResource}\n/** @type {Construct} */\nconst referenceFullConstruct = {tokenize: tokenizeReferenceFull}\n/** @type {Construct} */\nconst referenceCollapsedConstruct = {tokenize: tokenizeReferenceCollapsed}\n\n/** @type {Resolver} */\nfunction resolveAllLabelEnd(events) {\n  let index = -1\n\n  while (++index < events.length) {\n    const token = events[index][1]\n\n    if (\n      token.type === types.labelImage ||\n      token.type === types.labelLink ||\n      token.type === types.labelEnd\n    ) {\n      // Remove the marker.\n      events.splice(index + 1, token.type === types.labelImage ? 4 : 2)\n      token.type = types.data\n      index++\n    }\n  }\n\n  return events\n}\n\n/** @type {Resolver} */\nfunction resolveToLabelEnd(events, context) {\n  let index = events.length\n  let offset = 0\n  /** @type {Token} */\n  let token\n  /** @type {number | undefined} */\n  let open\n  /** @type {number | undefined} */\n  let close\n  /** @type {Array<Event>} */\n  let media\n\n  // Find an opening.\n  while (index--) {\n    token = events[index][1]\n\n    if (open) {\n      // If we see another link, or inactive link label, weâ€™ve been here before.\n      if (\n        token.type === types.link ||\n        (token.type === types.labelLink && token._inactive)\n      ) {\n        break\n      }\n\n      // Mark other link openings as inactive, as we canâ€™t have links in\n      // links.\n      if (events[index][0] === 'enter' && token.type === types.labelLink) {\n        token._inactive = true\n      }\n    } else if (close) {\n      if (\n        events[index][0] === 'enter' &&\n        (token.type === types.labelImage || token.type === types.labelLink) &&\n        !token._balanced\n      ) {\n        open = index\n\n        if (token.type !== types.labelLink) {\n          offset = 2\n          break\n        }\n      }\n    } else if (token.type === types.labelEnd) {\n      close = index\n    }\n  }\n\n  assert(open !== undefined, '`open` is supposed to be found')\n  assert(close !== undefined, '`close` is supposed to be found')\n\n  const group = {\n    type: events[open][1].type === types.labelLink ? types.link : types.image,\n    start: Object.assign({}, events[open][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  }\n\n  const label = {\n    type: types.label,\n    start: Object.assign({}, events[open][1].start),\n    end: Object.assign({}, events[close][1].end)\n  }\n\n  const text = {\n    type: types.labelText,\n    start: Object.assign({}, events[open + offset + 2][1].end),\n    end: Object.assign({}, events[close - 2][1].start)\n  }\n\n  media = [\n    ['enter', group, context],\n    ['enter', label, context]\n  ]\n\n  // Opening marker.\n  media = push(media, events.slice(open + 1, open + offset + 3))\n\n  // Text open.\n  media = push(media, [['enter', text, context]])\n\n  // Always populated by defaults.\n  assert(\n    context.parser.constructs.insideSpan.null,\n    'expected `insideSpan.null` to be populated'\n  )\n  // Between.\n  media = push(\n    media,\n    resolveAll(\n      context.parser.constructs.insideSpan.null,\n      events.slice(open + offset + 4, close - 3),\n      context\n    )\n  )\n\n  // Text close, marker close, label close.\n  media = push(media, [\n    ['exit', text, context],\n    events[close - 2],\n    events[close - 1],\n    ['exit', label, context]\n  ])\n\n  // Reference, resource, or so.\n  media = push(media, events.slice(close + 1))\n\n  // Media close.\n  media = push(media, [['exit', group, context]])\n\n  splice(events, open, events.length, media)\n\n  return events\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeLabelEnd(effects, ok, nok) {\n  const self = this\n  let index = self.events.length\n  /** @type {Token} */\n  let labelStart\n  /** @type {boolean} */\n  let defined\n\n  // Find an opening.\n  while (index--) {\n    if (\n      (self.events[index][1].type === types.labelImage ||\n        self.events[index][1].type === types.labelLink) &&\n      !self.events[index][1]._balanced\n    ) {\n      labelStart = self.events[index][1]\n      break\n    }\n  }\n\n  return start\n\n  /**\n   * Start of label end.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *       ^\n   * > | [a][b] c\n   *       ^\n   * > | [a][] b\n   *       ^\n   * > | [a] b\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    assert(code === codes.rightSquareBracket, 'expected `]`')\n\n    // If there is not an okay opening.\n    if (!labelStart) {\n      return nok(code)\n    }\n\n    // If the corresponding label (link) start is marked as inactive,\n    // it means weâ€™d be wrapping a link, like this:\n    //\n    // ```markdown\n    // > | a [b [c](d) e](f) g.\n    //                  ^\n    // ```\n    //\n    // We canâ€™t have that, so itâ€™s just balanced brackets.\n    if (labelStart._inactive) {\n      return labelEndNok(code)\n    }\n\n    defined = self.parser.defined.includes(\n      normalizeIdentifier(\n        self.sliceSerialize({start: labelStart.end, end: self.now()})\n      )\n    )\n    effects.enter(types.labelEnd)\n    effects.enter(types.labelMarker)\n    effects.consume(code)\n    effects.exit(types.labelMarker)\n    effects.exit(types.labelEnd)\n    return after\n  }\n\n  /**\n   * After `]`.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *       ^\n   * > | [a][b] c\n   *       ^\n   * > | [a][] b\n   *       ^\n   * > | [a] b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    // Note: `markdown-rs` also parses GFM footnotes here, which for us is in\n    // an extension.\n\n    // Resource (`[asd](fgh)`)?\n    if (code === codes.leftParenthesis) {\n      return effects.attempt(\n        resourceConstruct,\n        labelEndOk,\n        defined ? labelEndOk : labelEndNok\n      )(code)\n    }\n\n    // Full (`[asd][fgh]`) or collapsed (`[asd][]`) reference?\n    if (code === codes.leftSquareBracket) {\n      return effects.attempt(\n        referenceFullConstruct,\n        labelEndOk,\n        defined ? referenceNotFull : labelEndNok\n      )(code)\n    }\n\n    // Shortcut (`[asd]`) reference?\n    return defined ? labelEndOk(code) : labelEndNok(code)\n  }\n\n  /**\n   * After `]`, at `[`, but not at a full reference.\n   *\n   * > ðŸ‘‰ **Note**: we only get here if the label is defined.\n   *\n   * ```markdown\n   * > | [a][] b\n   *        ^\n   * > | [a] b\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceNotFull(code) {\n    return effects.attempt(\n      referenceCollapsedConstruct,\n      labelEndOk,\n      labelEndNok\n    )(code)\n  }\n\n  /**\n   * Done, we found something.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *           ^\n   * > | [a][b] c\n   *           ^\n   * > | [a][] b\n   *          ^\n   * > | [a] b\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelEndOk(code) {\n    // Note: `markdown-rs` does a bunch of stuff here.\n    return ok(code)\n  }\n\n  /**\n   * Done, itâ€™s nothing.\n   *\n   * There was an okay opening, but we didnâ€™t match anything.\n   *\n   * ```markdown\n   * > | [a](b c\n   *        ^\n   * > | [a][b c\n   *        ^\n   * > | [a] b\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelEndNok(code) {\n    labelStart._balanced = true\n    return nok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeResource(effects, ok, nok) {\n  return resourceStart\n\n  /**\n   * At a resource.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceStart(code) {\n    assert(code === codes.leftParenthesis, 'expected left paren')\n    effects.enter(types.resource)\n    effects.enter(types.resourceMarker)\n    effects.consume(code)\n    effects.exit(types.resourceMarker)\n    return resourceBefore\n  }\n\n  /**\n   * In resource, after `(`, at optional whitespace.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceBefore(code) {\n    return markdownLineEndingOrSpace(code)\n      ? factoryWhitespace(effects, resourceOpen)(code)\n      : resourceOpen(code)\n  }\n\n  /**\n   * In resource, after optional whitespace, at `)` or a destination.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceOpen(code) {\n    if (code === codes.rightParenthesis) {\n      return resourceEnd(code)\n    }\n\n    return factoryDestination(\n      effects,\n      resourceDestinationAfter,\n      resourceDestinationMissing,\n      types.resourceDestination,\n      types.resourceDestinationLiteral,\n      types.resourceDestinationLiteralMarker,\n      types.resourceDestinationRaw,\n      types.resourceDestinationString,\n      constants.linkResourceDestinationBalanceMax\n    )(code)\n  }\n\n  /**\n   * In resource, after destination, at optional whitespace.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceDestinationAfter(code) {\n    return markdownLineEndingOrSpace(code)\n      ? factoryWhitespace(effects, resourceBetween)(code)\n      : resourceEnd(code)\n  }\n\n  /**\n   * At invalid destination.\n   *\n   * ```markdown\n   * > | [a](<<) b\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceDestinationMissing(code) {\n    return nok(code)\n  }\n\n  /**\n   * In resource, after destination and whitespace, at `(` or title.\n   *\n   * ```markdown\n   * > | [a](b ) c\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceBetween(code) {\n    if (\n      code === codes.quotationMark ||\n      code === codes.apostrophe ||\n      code === codes.leftParenthesis\n    ) {\n      return factoryTitle(\n        effects,\n        resourceTitleAfter,\n        nok,\n        types.resourceTitle,\n        types.resourceTitleMarker,\n        types.resourceTitleString\n      )(code)\n    }\n\n    return resourceEnd(code)\n  }\n\n  /**\n   * In resource, after title, at optional whitespace.\n   *\n   * ```markdown\n   * > | [a](b \"c\") d\n   *              ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceTitleAfter(code) {\n    return markdownLineEndingOrSpace(code)\n      ? factoryWhitespace(effects, resourceEnd)(code)\n      : resourceEnd(code)\n  }\n\n  /**\n   * In resource, at `)`.\n   *\n   * ```markdown\n   * > | [a](b) d\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceEnd(code) {\n    if (code === codes.rightParenthesis) {\n      effects.enter(types.resourceMarker)\n      effects.consume(code)\n      effects.exit(types.resourceMarker)\n      effects.exit(types.resource)\n      return ok\n    }\n\n    return nok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeReferenceFull(effects, ok, nok) {\n  const self = this\n\n  return referenceFull\n\n  /**\n   * In a reference (full), at the `[`.\n   *\n   * ```markdown\n   * > | [a][b] d\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceFull(code) {\n    assert(code === codes.leftSquareBracket, 'expected left bracket')\n    return factoryLabel.call(\n      self,\n      effects,\n      referenceFullAfter,\n      referenceFullMissing,\n      types.reference,\n      types.referenceMarker,\n      types.referenceString\n    )(code)\n  }\n\n  /**\n   * In a reference (full), after `]`.\n   *\n   * ```markdown\n   * > | [a][b] d\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceFullAfter(code) {\n    return self.parser.defined.includes(\n      normalizeIdentifier(\n        self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1)\n      )\n    )\n      ? ok(code)\n      : nok(code)\n  }\n\n  /**\n   * In reference (full) that was missing.\n   *\n   * ```markdown\n   * > | [a][b d\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceFullMissing(code) {\n    return nok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeReferenceCollapsed(effects, ok, nok) {\n  return referenceCollapsedStart\n\n  /**\n   * In reference (collapsed), at `[`.\n   *\n   * > ðŸ‘‰ **Note**: we only get here if the label is defined.\n   *\n   * ```markdown\n   * > | [a][] d\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceCollapsedStart(code) {\n    // We only attempt a collapsed label if thereâ€™s a `[`.\n    assert(code === codes.leftSquareBracket, 'expected left bracket')\n    effects.enter(types.reference)\n    effects.enter(types.referenceMarker)\n    effects.consume(code)\n    effects.exit(types.referenceMarker)\n    return referenceCollapsedOpen\n  }\n\n  /**\n   * In reference (collapsed), at `]`.\n   *\n   * > ðŸ‘‰ **Note**: we only get here if the label is defined.\n   *\n   * ```markdown\n   * > | [a][] d\n   *         ^\n   * ```\n   *\n   *  @type {State}\n   */\n  function referenceCollapsedOpen(code) {\n    if (code === codes.rightSquareBracket) {\n      effects.enter(types.referenceMarker)\n      effects.consume(code)\n      effects.exit(types.referenceMarker)\n      effects.exit(types.reference)\n      return ok\n    }\n\n    return nok(code)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}
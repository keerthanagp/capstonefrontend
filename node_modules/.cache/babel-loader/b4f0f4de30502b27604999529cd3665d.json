{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Encoding} Encoding\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').ParseOptions} ParseOptions\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Value} Value\n *\n * @typedef {import('unist').Parent} UnistParent\n * @typedef {import('unist').Point} Point\n *\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n * @typedef {import('mdast').StaticPhrasingContent} StaticPhrasingContent\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').Break} Break\n * @typedef {import('mdast').Blockquote} Blockquote\n * @typedef {import('mdast').Code} Code\n * @typedef {import('mdast').Definition} Definition\n * @typedef {import('mdast').Emphasis} Emphasis\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('mdast').HTML} HTML\n * @typedef {import('mdast').Image} Image\n * @typedef {import('mdast').ImageReference} ImageReference\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('mdast').Link} Link\n * @typedef {import('mdast').LinkReference} LinkReference\n * @typedef {import('mdast').List} List\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').Strong} Strong\n * @typedef {import('mdast').Text} Text\n * @typedef {import('mdast').ThematicBreak} ThematicBreak\n * @typedef {import('mdast').ReferenceType} ReferenceType\n * @typedef {import('../index.js').CompileData} CompileData\n */\n\n/**\n * @typedef {Root | Content} Node\n * @typedef {Extract<Node, UnistParent>} Parent\n *\n * @typedef {Omit<UnistParent, 'type' | 'children'> & {type: 'fragment', children: Array<PhrasingContent>}} Fragment\n */\n\n/**\n * @callback Transform\n *   Extra transform, to change the AST afterwards.\n * @param {Root} tree\n *   Tree to transform.\n * @returns {Root | undefined | null | void}\n *   New tree or nothing (in which case the current tree is used).\n *\n * @callback Handle\n *   Handle a token.\n * @param {CompileContext} this\n *   Context.\n * @param {Token} token\n *   Current token.\n * @returns {void}\n *   Nothing.\n *\n * @typedef {Record<string, Handle>} Handles\n *   Token types mapping to handles\n *\n * @callback OnEnterError\n *   Handle the case where the `right` token is open, but it is closed (by the\n *   `left` token) or because we reached the end of the document.\n * @param {Omit<CompileContext, 'sliceSerialize'>} this\n *   Context.\n * @param {Token | undefined} left\n *   Left token.\n * @param {Token} right\n *   Right token.\n * @returns {void}\n *   Nothing.\n *\n * @callback OnExitError\n *   Handle the case where the `right` token is open but it is closed by\n *   exiting the `left` token.\n * @param {Omit<CompileContext, 'sliceSerialize'>} this\n *   Context.\n * @param {Token} left\n *   Left token.\n * @param {Token} right\n *   Right token.\n * @returns {void}\n *   Nothing.\n *\n * @typedef {[Token, OnEnterError | undefined]} TokenTuple\n *   Open token on the stack, with an optional error handler for when\n *   that token isn’t closed properly.\n */\n\n/**\n * @typedef Config\n *   Configuration.\n *\n *   We have our defaults, but extensions will add more.\n * @property {Array<string>} canContainEols\n *   Token types where line endings are used.\n * @property {Handles} enter\n *   Opening handles.\n * @property {Handles} exit\n *   Closing handles.\n * @property {Array<Transform>} transforms\n *   Tree transforms.\n *\n * @typedef {Partial<Config>} Extension\n *   Change how markdown tokens from micromark are turned into mdast.\n *\n * @typedef CompileContext\n *   mdast compiler context.\n * @property {Array<Node | Fragment>} stack\n *   Stack of nodes.\n * @property {Array<TokenTuple>} tokenStack\n *   Stack of tokens.\n * @property {<Key extends keyof CompileData>(key: Key) => CompileData[Key]} getData\n *   Get data from the key/value store.\n * @property {<Key extends keyof CompileData>(key: Key, value?: CompileData[Key]) => void} setData\n *   Set data into the key/value store.\n * @property {(this: CompileContext) => void} buffer\n *   Capture some of the output data.\n * @property {(this: CompileContext) => string} resume\n *   Stop capturing and access the output data.\n * @property {<Kind extends Node>(this: CompileContext, node: Kind, token: Token, onError?: OnEnterError) => Kind} enter\n *   Enter a token.\n * @property {(this: CompileContext, token: Token, onError?: OnExitError) => Node} exit\n *   Exit a token.\n * @property {TokenizeContext['sliceSerialize']} sliceSerialize\n *   Get the string value of a token.\n * @property {Config} config\n *   Configuration.\n *\n * @typedef FromMarkdownOptions\n *   Configuration for how to build mdast.\n * @property {Array<Extension | Array<Extension>> | null | undefined} [mdastExtensions]\n *   Extensions for this utility to change how tokens are turned into a tree.\n *\n * @typedef {ParseOptions & FromMarkdownOptions} Options\n *   Configuration.\n */\n// To do: micromark: create a registry of tokens?\n// To do: next major: don’t return given `Node` from `enter`.\n// To do: next major: remove setter/getter.\nimport { ok as assert } from 'uvu/assert';\nimport { toString } from 'mdast-util-to-string';\nimport { parse } from 'micromark/lib/parse.js';\nimport { preprocess } from 'micromark/lib/preprocess.js';\nimport { postprocess } from 'micromark/lib/postprocess.js';\nimport { decodeNumericCharacterReference } from 'micromark-util-decode-numeric-character-reference';\nimport { decodeString } from 'micromark-util-decode-string';\nimport { normalizeIdentifier } from 'micromark-util-normalize-identifier';\nimport { codes } from 'micromark-util-symbol/codes.js';\nimport { constants } from 'micromark-util-symbol/constants.js';\nimport { types } from 'micromark-util-symbol/types.js';\nimport { decodeNamedCharacterReference } from 'decode-named-character-reference';\nimport { stringifyPosition } from 'unist-util-stringify-position';\nconst own = {}.hasOwnProperty;\n/**\n * @param value\n *   Markdown to parse.\n * @param encoding\n *   Character encoding for when `value` is `Buffer`.\n * @param options\n *   Configuration.\n * @returns\n *   mdast tree.\n */\n\nexport const fromMarkdown =\n/**\n * @type {(\n *   ((value: Value, encoding: Encoding, options?: Options | null | undefined) => Root) &\n *   ((value: Value, options?: Options | null | undefined) => Root)\n * )}\n */\n\n/**\n * @param {Value} value\n * @param {Encoding | Options | null | undefined} [encoding]\n * @param {Options | null | undefined} [options]\n * @returns {Root}\n */\nfunction (value, encoding, options) {\n  if (typeof encoding !== 'string') {\n    options = encoding;\n    encoding = undefined;\n  }\n\n  return compiler(options)(postprocess(parse(options).document().write(preprocess()(value, encoding, true))));\n};\n/**\n * Note this compiler only understand complete buffering, not streaming.\n *\n * @param {Options | null | undefined} [options]\n */\n\nfunction compiler(options) {\n  /** @type {Config} */\n  const config = {\n    transforms: [],\n    canContainEols: ['emphasis', 'fragment', 'heading', 'paragraph', 'strong'],\n    enter: {\n      autolink: opener(link),\n      autolinkProtocol: onenterdata,\n      autolinkEmail: onenterdata,\n      atxHeading: opener(heading),\n      blockQuote: opener(blockQuote),\n      characterEscape: onenterdata,\n      characterReference: onenterdata,\n      codeFenced: opener(codeFlow),\n      codeFencedFenceInfo: buffer,\n      codeFencedFenceMeta: buffer,\n      codeIndented: opener(codeFlow, buffer),\n      codeText: opener(codeText, buffer),\n      codeTextData: onenterdata,\n      data: onenterdata,\n      codeFlowValue: onenterdata,\n      definition: opener(definition),\n      definitionDestinationString: buffer,\n      definitionLabelString: buffer,\n      definitionTitleString: buffer,\n      emphasis: opener(emphasis),\n      hardBreakEscape: opener(hardBreak),\n      hardBreakTrailing: opener(hardBreak),\n      htmlFlow: opener(html, buffer),\n      htmlFlowData: onenterdata,\n      htmlText: opener(html, buffer),\n      htmlTextData: onenterdata,\n      image: opener(image),\n      label: buffer,\n      link: opener(link),\n      listItem: opener(listItem),\n      listItemValue: onenterlistitemvalue,\n      listOrdered: opener(list, onenterlistordered),\n      listUnordered: opener(list),\n      paragraph: opener(paragraph),\n      reference: onenterreference,\n      referenceString: buffer,\n      resourceDestinationString: buffer,\n      resourceTitleString: buffer,\n      setextHeading: opener(heading),\n      strong: opener(strong),\n      thematicBreak: opener(thematicBreak)\n    },\n    exit: {\n      atxHeading: closer(),\n      atxHeadingSequence: onexitatxheadingsequence,\n      autolink: closer(),\n      autolinkEmail: onexitautolinkemail,\n      autolinkProtocol: onexitautolinkprotocol,\n      blockQuote: closer(),\n      characterEscapeValue: onexitdata,\n      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,\n      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,\n      characterReferenceValue: onexitcharacterreferencevalue,\n      codeFenced: closer(onexitcodefenced),\n      codeFencedFence: onexitcodefencedfence,\n      codeFencedFenceInfo: onexitcodefencedfenceinfo,\n      codeFencedFenceMeta: onexitcodefencedfencemeta,\n      codeFlowValue: onexitdata,\n      codeIndented: closer(onexitcodeindented),\n      codeText: closer(onexitcodetext),\n      codeTextData: onexitdata,\n      data: onexitdata,\n      definition: closer(),\n      definitionDestinationString: onexitdefinitiondestinationstring,\n      definitionLabelString: onexitdefinitionlabelstring,\n      definitionTitleString: onexitdefinitiontitlestring,\n      emphasis: closer(),\n      hardBreakEscape: closer(onexithardbreak),\n      hardBreakTrailing: closer(onexithardbreak),\n      htmlFlow: closer(onexithtmlflow),\n      htmlFlowData: onexitdata,\n      htmlText: closer(onexithtmltext),\n      htmlTextData: onexitdata,\n      image: closer(onexitimage),\n      label: onexitlabel,\n      labelText: onexitlabeltext,\n      lineEnding: onexitlineending,\n      link: closer(onexitlink),\n      listItem: closer(),\n      listOrdered: closer(),\n      listUnordered: closer(),\n      paragraph: closer(),\n      referenceString: onexitreferencestring,\n      resourceDestinationString: onexitresourcedestinationstring,\n      resourceTitleString: onexitresourcetitlestring,\n      resource: onexitresource,\n      setextHeading: closer(onexitsetextheading),\n      setextHeadingLineSequence: onexitsetextheadinglinesequence,\n      setextHeadingText: onexitsetextheadingtext,\n      strong: closer(),\n      thematicBreak: closer()\n    }\n  };\n  configure(config, (options || {}).mdastExtensions || []);\n  /** @type {CompileData} */\n\n  const data = {};\n  return compile;\n  /**\n   * Turn micromark events into an mdast tree.\n   *\n   * @param {Array<Event>} events\n   *   Events.\n   * @returns {Root}\n   *   mdast tree.\n   */\n\n  function compile(events) {\n    /** @type {Root} */\n    let tree = {\n      type: 'root',\n      children: []\n    };\n    /** @type {Omit<CompileContext, 'sliceSerialize'>} */\n\n    const context = {\n      stack: [tree],\n      tokenStack: [],\n      config,\n      enter,\n      exit,\n      buffer,\n      resume,\n      setData,\n      getData\n    };\n    /** @type {Array<number>} */\n\n    const listStack = [];\n    let index = -1;\n\n    while (++index < events.length) {\n      // We preprocess lists to add `listItem` tokens, and to infer whether\n      // items the list itself are spread out.\n      if (events[index][1].type === types.listOrdered || events[index][1].type === types.listUnordered) {\n        if (events[index][0] === 'enter') {\n          listStack.push(index);\n        } else {\n          const tail = listStack.pop();\n          assert(typeof tail === 'number', 'expected list ot be open');\n          index = prepareList(events, tail, index);\n        }\n      }\n    }\n\n    index = -1;\n\n    while (++index < events.length) {\n      const handler = config[events[index][0]];\n\n      if (own.call(handler, events[index][1].type)) {\n        handler[events[index][1].type].call(Object.assign({\n          sliceSerialize: events[index][2].sliceSerialize\n        }, context), events[index][1]);\n      }\n    } // Handle tokens still being open.\n\n\n    if (context.tokenStack.length > 0) {\n      const tail = context.tokenStack[context.tokenStack.length - 1];\n      const handler = tail[1] || defaultOnError;\n      handler.call(context, undefined, tail[0]);\n    } // Figure out `root` position.\n\n\n    tree.position = {\n      start: point(events.length > 0 ? events[0][1].start : {\n        line: 1,\n        column: 1,\n        offset: 0\n      }),\n      end: point(events.length > 0 ? events[events.length - 2][1].end : {\n        line: 1,\n        column: 1,\n        offset: 0\n      })\n    }; // Call transforms.\n\n    index = -1;\n\n    while (++index < config.transforms.length) {\n      tree = config.transforms[index](tree) || tree;\n    }\n\n    return tree;\n  }\n  /**\n   * @param {Array<Event>} events\n   * @param {number} start\n   * @param {number} length\n   * @returns {number}\n   */\n\n\n  function prepareList(events, start, length) {\n    let index = start - 1;\n    let containerBalance = -1;\n    let listSpread = false;\n    /** @type {Token | undefined} */\n\n    let listItem;\n    /** @type {number | undefined} */\n\n    let lineIndex;\n    /** @type {number | undefined} */\n\n    let firstBlankLineIndex;\n    /** @type {boolean | undefined} */\n\n    let atMarker;\n\n    while (++index <= length) {\n      const event = events[index];\n\n      if (event[1].type === types.listUnordered || event[1].type === types.listOrdered || event[1].type === types.blockQuote) {\n        if (event[0] === 'enter') {\n          containerBalance++;\n        } else {\n          containerBalance--;\n        }\n\n        atMarker = undefined;\n      } else if (event[1].type === types.lineEndingBlank) {\n        if (event[0] === 'enter') {\n          if (listItem && !atMarker && !containerBalance && !firstBlankLineIndex) {\n            firstBlankLineIndex = index;\n          }\n\n          atMarker = undefined;\n        }\n      } else if (event[1].type === types.linePrefix || event[1].type === types.listItemValue || event[1].type === types.listItemMarker || event[1].type === types.listItemPrefix || event[1].type === types.listItemPrefixWhitespace) {// Empty.\n      } else {\n        atMarker = undefined;\n      }\n\n      if (!containerBalance && event[0] === 'enter' && event[1].type === types.listItemPrefix || containerBalance === -1 && event[0] === 'exit' && (event[1].type === types.listUnordered || event[1].type === types.listOrdered)) {\n        if (listItem) {\n          let tailIndex = index;\n          lineIndex = undefined;\n\n          while (tailIndex--) {\n            const tailEvent = events[tailIndex];\n\n            if (tailEvent[1].type === types.lineEnding || tailEvent[1].type === types.lineEndingBlank) {\n              if (tailEvent[0] === 'exit') continue;\n\n              if (lineIndex) {\n                events[lineIndex][1].type = types.lineEndingBlank;\n                listSpread = true;\n              }\n\n              tailEvent[1].type = types.lineEnding;\n              lineIndex = tailIndex;\n            } else if (tailEvent[1].type === types.linePrefix || tailEvent[1].type === types.blockQuotePrefix || tailEvent[1].type === types.blockQuotePrefixWhitespace || tailEvent[1].type === types.blockQuoteMarker || tailEvent[1].type === types.listItemIndent) {// Empty\n            } else {\n              break;\n            }\n          }\n\n          if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {\n            listItem._spread = true;\n          } // Fix position.\n\n\n          listItem.end = Object.assign({}, lineIndex ? events[lineIndex][1].start : event[1].end);\n          events.splice(lineIndex || index, 0, ['exit', listItem, event[2]]);\n          index++;\n          length++;\n        } // Create a new list item.\n\n\n        if (event[1].type === types.listItemPrefix) {\n          listItem = {\n            type: 'listItem',\n            _spread: false,\n            start: Object.assign({}, event[1].start),\n            // @ts-expect-error: we’ll add `end` in a second.\n            end: undefined\n          }; // @ts-expect-error: `listItem` is most definitely defined, TS...\n\n          events.splice(index, 0, ['enter', listItem, event[2]]);\n          index++;\n          length++;\n          firstBlankLineIndex = undefined;\n          atMarker = true;\n        }\n      }\n    }\n\n    events[start][1]._spread = listSpread;\n    return length;\n  }\n  /**\n   * Set data.\n   *\n   * @template {keyof CompileData} Key\n   *   Field type.\n   * @param {Key} key\n   *   Key of field.\n   * @param {CompileData[Key]} [value]\n   *   New value.\n   * @returns {void}\n   *   Nothing.\n   */\n\n\n  function setData(key, value) {\n    data[key] = value;\n  }\n  /**\n   * Get data.\n   *\n   * @template {keyof CompileData} Key\n   *   Field type.\n   * @param {Key} key\n   *   Key of field.\n   * @returns {CompileData[Key]}\n   *   Value.\n   */\n\n\n  function getData(key) {\n    return data[key];\n  }\n  /**\n   * Create an opener handle.\n   *\n   * @param {(token: Token) => Node} create\n   *   Create a node.\n   * @param {Handle} [and]\n   *   Optional function to also run.\n   * @returns {Handle}\n   *   Handle.\n   */\n\n\n  function opener(create, and) {\n    return open;\n    /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {void}\n     */\n\n    function open(token) {\n      enter.call(this, create(token), token);\n      if (and) and.call(this, token);\n    }\n  }\n  /**\n   * @this {CompileContext}\n   * @returns {void}\n   */\n\n\n  function buffer() {\n    this.stack.push({\n      type: 'fragment',\n      children: []\n    });\n  }\n  /**\n   * @template {Node} Kind\n   *   Node type.\n   * @this {CompileContext}\n   *   Context.\n   * @param {Kind} node\n   *   Node to enter.\n   * @param {Token} token\n   *   Corresponding token.\n   * @param {OnEnterError | undefined} [errorHandler]\n   *   Handle the case where this token is open, but it is closed by something else.\n   * @returns {Kind}\n   *   The given node.\n   */\n\n\n  function enter(node, token, errorHandler) {\n    const parent = this.stack[this.stack.length - 1];\n    assert(parent, 'expected `parent`');\n    assert('children' in parent, 'expected `parent`'); // @ts-expect-error: Assume `Node` can exist as a child of `parent`.\n\n    parent.children.push(node);\n    this.stack.push(node);\n    this.tokenStack.push([token, errorHandler]); // @ts-expect-error: `end` will be patched later.\n\n    node.position = {\n      start: point(token.start)\n    };\n    return node;\n  }\n  /**\n   * Create a closer handle.\n   *\n   * @param {Handle} [and]\n   *   Optional function to also run.\n   * @returns {Handle}\n   *   Handle.\n   */\n\n\n  function closer(and) {\n    return close;\n    /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {void}\n     */\n\n    function close(token) {\n      if (and) and.call(this, token);\n      exit.call(this, token);\n    }\n  }\n  /**\n   * @this {CompileContext}\n   *   Context.\n   * @param {Token} token\n   *   Corresponding token.\n   * @param {OnExitError | undefined} [onExitError]\n   *   Handle the case where another token is open.\n   * @returns {Node}\n   *   The closed node.\n   */\n\n\n  function exit(token, onExitError) {\n    const node = this.stack.pop();\n    assert(node, 'expected `node`');\n    const open = this.tokenStack.pop();\n\n    if (!open) {\n      throw new Error('Cannot close `' + token.type + '` (' + stringifyPosition({\n        start: token.start,\n        end: token.end\n      }) + '): it’s not open');\n    } else if (open[0].type !== token.type) {\n      if (onExitError) {\n        onExitError.call(this, token, open[0]);\n      } else {\n        const handler = open[1] || defaultOnError;\n        handler.call(this, token, open[0]);\n      }\n    }\n\n    assert(node.type !== 'fragment', 'unexpected fragment `exit`ed');\n    assert(node.position, 'expected `position` to be defined');\n    node.position.end = point(token.end);\n    return node;\n  }\n  /**\n   * @this {CompileContext}\n   * @returns {string}\n   */\n\n\n  function resume() {\n    return toString(this.stack.pop());\n  } //\n  // Handlers.\n  //\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onenterlistordered() {\n    setData('expectingFirstListItemValue', true);\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onenterlistitemvalue(token) {\n    if (getData('expectingFirstListItemValue')) {\n      const ancestor = this.stack[this.stack.length - 2];\n      assert(ancestor, 'expected nodes on stack');\n      assert(ancestor.type === 'list', 'expected list on stack');\n      ancestor.start = Number.parseInt(this.sliceSerialize(token), constants.numericBaseDecimal);\n      setData('expectingFirstListItemValue');\n    }\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitcodefencedfenceinfo() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    assert(node, 'expected node on stack');\n    assert(node.type === 'code', 'expected code on stack');\n    node.lang = data;\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitcodefencedfencemeta() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    assert(node, 'expected node on stack');\n    assert(node.type === 'code', 'expected code on stack');\n    node.meta = data;\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitcodefencedfence() {\n    // Exit if this is the closing fence.\n    if (getData('flowCodeInside')) return;\n    this.buffer();\n    setData('flowCodeInside', true);\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitcodefenced() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    assert(node, 'expected node on stack');\n    assert(node.type === 'code', 'expected code on stack');\n    node.value = data.replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, '');\n    setData('flowCodeInside');\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitcodeindented() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    assert(node, 'expected node on stack');\n    assert(node.type === 'code', 'expected code on stack');\n    node.value = data.replace(/(\\r?\\n|\\r)$/g, '');\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitdefinitionlabelstring(token) {\n    const label = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    assert(node, 'expected node on stack');\n    assert(node.type === 'definition', 'expected definition on stack');\n    node.label = label;\n    node.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitdefinitiontitlestring() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    assert(node, 'expected node on stack');\n    assert(node.type === 'definition', 'expected definition on stack');\n    node.title = data;\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitdefinitiondestinationstring() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    assert(node, 'expected node on stack');\n    assert(node.type === 'definition', 'expected definition on stack');\n    node.url = data;\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitatxheadingsequence(token) {\n    const node = this.stack[this.stack.length - 1];\n    assert(node, 'expected node on stack');\n    assert(node.type === 'heading', 'expected heading on stack');\n\n    if (!node.depth) {\n      const depth = this.sliceSerialize(token).length;\n      assert(depth === 1 || depth === 2 || depth === 3 || depth === 4 || depth === 5 || depth === 6, 'expected `depth` between `1` and `6`');\n      node.depth = depth;\n    }\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitsetextheadingtext() {\n    setData('setextHeadingSlurpLineEnding', true);\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitsetextheadinglinesequence(token) {\n    const node = this.stack[this.stack.length - 1];\n    assert(node, 'expected node on stack');\n    assert(node.type === 'heading', 'expected heading on stack');\n    node.depth = this.sliceSerialize(token).charCodeAt(0) === codes.equalsTo ? 1 : 2;\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitsetextheading() {\n    setData('setextHeadingSlurpLineEnding');\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onenterdata(token) {\n    const node = this.stack[this.stack.length - 1];\n    assert(node, 'expected node on stack');\n    assert('children' in node, 'expected parent on stack');\n    let tail = node.children[node.children.length - 1];\n\n    if (!tail || tail.type !== 'text') {\n      // Add a new text node.\n      tail = text(); // @ts-expect-error: we’ll add `end` later.\n\n      tail.position = {\n        start: point(token.start)\n      }; // @ts-expect-error: Assume `parent` accepts `text`.\n\n      node.children.push(tail);\n    }\n\n    this.stack.push(tail);\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitdata(token) {\n    const tail = this.stack.pop();\n    assert(tail, 'expected a `node` to be on the stack');\n    assert('value' in tail, 'expected a `literal` to be on the stack');\n    assert(tail.position, 'expected `node` to have an open position');\n    tail.value += this.sliceSerialize(token);\n    tail.position.end = point(token.end);\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitlineending(token) {\n    const context = this.stack[this.stack.length - 1];\n    assert(context, 'expected `node`'); // If we’re at a hard break, include the line ending in there.\n\n    if (getData('atHardBreak')) {\n      assert('children' in context, 'expected `parent`');\n      const tail = context.children[context.children.length - 1];\n      assert(tail.position, 'expected tail to have a starting position');\n      tail.position.end = point(token.end);\n      setData('atHardBreak');\n      return;\n    }\n\n    if (!getData('setextHeadingSlurpLineEnding') && config.canContainEols.includes(context.type)) {\n      onenterdata.call(this, token);\n      onexitdata.call(this, token);\n    }\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexithardbreak() {\n    setData('atHardBreak', true);\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexithtmlflow() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    assert(node, 'expected node on stack');\n    assert(node.type === 'html', 'expected html on stack');\n    node.value = data;\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexithtmltext() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    assert(node, 'expected node on stack');\n    assert(node.type === 'html', 'expected html on stack');\n    node.value = data;\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitcodetext() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    assert(node, 'expected node on stack');\n    assert(node.type === 'inlineCode', 'expected inline code on stack');\n    node.value = data;\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitlink() {\n    const node = this.stack[this.stack.length - 1];\n    assert(node, 'expected node on stack');\n    assert(node.type === 'link', 'expected link on stack'); // Note: there are also `identifier` and `label` fields on this link node!\n    // These are used / cleaned here.\n    // To do: clean.\n\n    if (getData('inReference')) {\n      /** @type {ReferenceType} */\n      const referenceType = getData('referenceType') || 'shortcut';\n      node.type += 'Reference'; // @ts-expect-error: mutate.\n\n      node.referenceType = referenceType; // @ts-expect-error: mutate.\n\n      delete node.url;\n      delete node.title;\n    } else {\n      // @ts-expect-error: mutate.\n      delete node.identifier; // @ts-expect-error: mutate.\n\n      delete node.label;\n    }\n\n    setData('referenceType');\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitimage() {\n    const node = this.stack[this.stack.length - 1];\n    assert(node, 'expected node on stack');\n    assert(node.type === 'image', 'expected image on stack'); // Note: there are also `identifier` and `label` fields on this link node!\n    // These are used / cleaned here.\n    // To do: clean.\n\n    if (getData('inReference')) {\n      /** @type {ReferenceType} */\n      const referenceType = getData('referenceType') || 'shortcut';\n      node.type += 'Reference'; // @ts-expect-error: mutate.\n\n      node.referenceType = referenceType; // @ts-expect-error: mutate.\n\n      delete node.url;\n      delete node.title;\n    } else {\n      // @ts-expect-error: mutate.\n      delete node.identifier; // @ts-expect-error: mutate.\n\n      delete node.label;\n    }\n\n    setData('referenceType');\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitlabeltext(token) {\n    const string = this.sliceSerialize(token);\n    const ancestor = this.stack[this.stack.length - 2];\n    assert(ancestor, 'expected ancestor on stack');\n    assert(ancestor.type === 'image' || ancestor.type === 'link', 'expected image or link on stack'); // @ts-expect-error: stash this on the node, as it might become a reference\n    // later.\n\n    ancestor.label = decodeString(string); // @ts-expect-error: same as above.\n\n    ancestor.identifier = normalizeIdentifier(string).toLowerCase();\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitlabel() {\n    const fragment = this.stack[this.stack.length - 1];\n    assert(fragment, 'expected node on stack');\n    assert(fragment.type === 'fragment', 'expected fragment on stack');\n    const value = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    assert(node, 'expected node on stack');\n    assert(node.type === 'image' || node.type === 'link', 'expected image or link on stack'); // Assume a reference.\n\n    setData('inReference', true);\n\n    if (node.type === 'link') {\n      /** @type {Array<StaticPhrasingContent>} */\n      // @ts-expect-error: Assume static phrasing content.\n      const children = fragment.children;\n      node.children = children;\n    } else {\n      node.alt = value;\n    }\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitresourcedestinationstring() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    assert(node, 'expected node on stack');\n    assert(node.type === 'image' || node.type === 'link', 'expected image or link on stack');\n    node.url = data;\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitresourcetitlestring() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    assert(node, 'expected node on stack');\n    assert(node.type === 'image' || node.type === 'link', 'expected image or link on stack');\n    node.title = data;\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitresource() {\n    setData('inReference');\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onenterreference() {\n    setData('referenceType', 'collapsed');\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitreferencestring(token) {\n    const label = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    assert(node, 'expected node on stack');\n    assert(node.type === 'image' || node.type === 'link', 'expected image reference or link reference on stack'); // @ts-expect-error: stash this on the node, as it might become a reference\n    // later.\n\n    node.label = label; // @ts-expect-error: same as above.\n\n    node.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();\n    setData('referenceType', 'full');\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitcharacterreferencemarker(token) {\n    assert(token.type === 'characterReferenceMarkerNumeric' || token.type === 'characterReferenceMarkerHexadecimal');\n    setData('characterReferenceType', token.type);\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitcharacterreferencevalue(token) {\n    const data = this.sliceSerialize(token);\n    const type = getData('characterReferenceType');\n    /** @type {string} */\n\n    let value;\n\n    if (type) {\n      value = decodeNumericCharacterReference(data, type === types.characterReferenceMarkerNumeric ? constants.numericBaseDecimal : constants.numericBaseHexadecimal);\n      setData('characterReferenceType');\n    } else {\n      const result = decodeNamedCharacterReference(data);\n      assert(result !== false, 'expected reference to decode');\n      value = result;\n    }\n\n    const tail = this.stack.pop();\n    assert(tail, 'expected `node`');\n    assert(tail.position, 'expected `node.position`');\n    assert('value' in tail, 'expected `node.value`');\n    tail.value += value;\n    tail.position.end = point(token.end);\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitautolinkprotocol(token) {\n    onexitdata.call(this, token);\n    const node = this.stack[this.stack.length - 1];\n    assert(node, 'expected node on stack');\n    assert(node.type === 'link', 'expected link on stack');\n    node.url = this.sliceSerialize(token);\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitautolinkemail(token) {\n    onexitdata.call(this, token);\n    const node = this.stack[this.stack.length - 1];\n    assert(node, 'expected node on stack');\n    assert(node.type === 'link', 'expected link on stack');\n    node.url = 'mailto:' + this.sliceSerialize(token);\n  } //\n  // Creaters.\n  //\n\n  /** @returns {Blockquote} */\n\n\n  function blockQuote() {\n    return {\n      type: 'blockquote',\n      children: []\n    };\n  }\n  /** @returns {Code} */\n\n\n  function codeFlow() {\n    return {\n      type: 'code',\n      lang: null,\n      meta: null,\n      value: ''\n    };\n  }\n  /** @returns {InlineCode} */\n\n\n  function codeText() {\n    return {\n      type: 'inlineCode',\n      value: ''\n    };\n  }\n  /** @returns {Definition} */\n\n\n  function definition() {\n    return {\n      type: 'definition',\n      identifier: '',\n      label: null,\n      title: null,\n      url: ''\n    };\n  }\n  /** @returns {Emphasis} */\n\n\n  function emphasis() {\n    return {\n      type: 'emphasis',\n      children: []\n    };\n  }\n  /** @returns {Heading} */\n\n\n  function heading() {\n    // @ts-expect-error `depth` will be set later.\n    return {\n      type: 'heading',\n      depth: undefined,\n      children: []\n    };\n  }\n  /** @returns {Break} */\n\n\n  function hardBreak() {\n    return {\n      type: 'break'\n    };\n  }\n  /** @returns {HTML} */\n\n\n  function html() {\n    return {\n      type: 'html',\n      value: ''\n    };\n  }\n  /** @returns {Image} */\n\n\n  function image() {\n    return {\n      type: 'image',\n      title: null,\n      url: '',\n      alt: null\n    };\n  }\n  /** @returns {Link} */\n\n\n  function link() {\n    return {\n      type: 'link',\n      title: null,\n      url: '',\n      children: []\n    };\n  }\n  /**\n   * @param {Token} token\n   * @returns {List}\n   */\n\n\n  function list(token) {\n    return {\n      type: 'list',\n      ordered: token.type === 'listOrdered',\n      start: null,\n      spread: token._spread,\n      children: []\n    };\n  }\n  /**\n   * @param {Token} token\n   * @returns {ListItem}\n   */\n\n\n  function listItem(token) {\n    return {\n      type: 'listItem',\n      spread: token._spread,\n      checked: null,\n      children: []\n    };\n  }\n  /** @returns {Paragraph} */\n\n\n  function paragraph() {\n    return {\n      type: 'paragraph',\n      children: []\n    };\n  }\n  /** @returns {Strong} */\n\n\n  function strong() {\n    return {\n      type: 'strong',\n      children: []\n    };\n  }\n  /** @returns {Text} */\n\n\n  function text() {\n    return {\n      type: 'text',\n      value: ''\n    };\n  }\n  /** @returns {ThematicBreak} */\n\n\n  function thematicBreak() {\n    return {\n      type: 'thematicBreak'\n    };\n  }\n}\n/**\n * Copy a point-like value.\n *\n * @param {Point} d\n *   Point-like value.\n * @returns {Point}\n *   unist point.\n */\n\n\nfunction point(d) {\n  return {\n    line: d.line,\n    column: d.column,\n    offset: d.offset\n  };\n}\n/**\n * @param {Config} combined\n * @param {Array<Extension | Array<Extension>>} extensions\n * @returns {void}\n */\n\n\nfunction configure(combined, extensions) {\n  let index = -1;\n\n  while (++index < extensions.length) {\n    const value = extensions[index];\n\n    if (Array.isArray(value)) {\n      configure(combined, value);\n    } else {\n      extension(combined, value);\n    }\n  }\n}\n/**\n * @param {Config} combined\n * @param {Extension} extension\n * @returns {void}\n */\n\n\nfunction extension(combined, extension) {\n  /** @type {keyof Extension} */\n  let key;\n\n  for (key in extension) {\n    if (own.call(extension, key)) {\n      if (key === 'canContainEols') {\n        const right = extension[key];\n\n        if (right) {\n          combined[key].push(...right);\n        }\n      } else if (key === 'transforms') {\n        const right = extension[key];\n\n        if (right) {\n          combined[key].push(...right);\n        }\n      } else if (key === 'enter' || key === 'exit') {\n        const right = extension[key];\n\n        if (right) {\n          Object.assign(combined[key], right);\n        }\n      }\n    }\n  }\n}\n/** @type {OnEnterError} */\n\n\nfunction defaultOnError(left, right) {\n  if (left) {\n    throw new Error('Cannot close `' + left.type + '` (' + stringifyPosition({\n      start: left.start,\n      end: left.end\n    }) + '): a different token (`' + right.type + '`, ' + stringifyPosition({\n      start: right.start,\n      end: right.end\n    }) + ') is open');\n  } else {\n    throw new Error('Cannot close document, a token (`' + right.type + '`, ' + stringifyPosition({\n      start: right.start,\n      end: right.end\n    }) + ') is still open');\n  }\n}","map":{"version":3,"sources":["D:/com lab/react/keerthana/auth2/AuthInMern/client/node_modules/mdast-util-from-markdown/dev/lib/index.js"],"names":["ok","assert","toString","parse","preprocess","postprocess","decodeNumericCharacterReference","decodeString","normalizeIdentifier","codes","constants","types","decodeNamedCharacterReference","stringifyPosition","own","hasOwnProperty","fromMarkdown","value","encoding","options","undefined","compiler","document","write","config","transforms","canContainEols","enter","autolink","opener","link","autolinkProtocol","onenterdata","autolinkEmail","atxHeading","heading","blockQuote","characterEscape","characterReference","codeFenced","codeFlow","codeFencedFenceInfo","buffer","codeFencedFenceMeta","codeIndented","codeText","codeTextData","data","codeFlowValue","definition","definitionDestinationString","definitionLabelString","definitionTitleString","emphasis","hardBreakEscape","hardBreak","hardBreakTrailing","htmlFlow","html","htmlFlowData","htmlText","htmlTextData","image","label","listItem","listItemValue","onenterlistitemvalue","listOrdered","list","onenterlistordered","listUnordered","paragraph","reference","onenterreference","referenceString","resourceDestinationString","resourceTitleString","setextHeading","strong","thematicBreak","exit","closer","atxHeadingSequence","onexitatxheadingsequence","onexitautolinkemail","onexitautolinkprotocol","characterEscapeValue","onexitdata","characterReferenceMarkerHexadecimal","onexitcharacterreferencemarker","characterReferenceMarkerNumeric","characterReferenceValue","onexitcharacterreferencevalue","onexitcodefenced","codeFencedFence","onexitcodefencedfence","onexitcodefencedfenceinfo","onexitcodefencedfencemeta","onexitcodeindented","onexitcodetext","onexitdefinitiondestinationstring","onexitdefinitionlabelstring","onexitdefinitiontitlestring","onexithardbreak","onexithtmlflow","onexithtmltext","onexitimage","onexitlabel","labelText","onexitlabeltext","lineEnding","onexitlineending","onexitlink","onexitreferencestring","onexitresourcedestinationstring","onexitresourcetitlestring","resource","onexitresource","onexitsetextheading","setextHeadingLineSequence","onexitsetextheadinglinesequence","setextHeadingText","onexitsetextheadingtext","configure","mdastExtensions","compile","events","tree","type","children","context","stack","tokenStack","resume","setData","getData","listStack","index","length","push","tail","pop","prepareList","handler","call","Object","assign","sliceSerialize","defaultOnError","position","start","point","line","column","offset","end","containerBalance","listSpread","lineIndex","firstBlankLineIndex","atMarker","event","lineEndingBlank","linePrefix","listItemMarker","listItemPrefix","listItemPrefixWhitespace","tailIndex","tailEvent","blockQuotePrefix","blockQuotePrefixWhitespace","blockQuoteMarker","listItemIndent","_spread","splice","key","create","and","open","token","node","errorHandler","parent","close","onExitError","Error","ancestor","Number","parseInt","numericBaseDecimal","lang","meta","replace","identifier","toLowerCase","title","url","depth","charCodeAt","equalsTo","text","includes","referenceType","string","fragment","alt","numericBaseHexadecimal","result","ordered","spread","checked","d","combined","extensions","Array","isArray","extension","right","left"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA,SAAQA,EAAE,IAAIC,MAAd,QAA2B,YAA3B;AACA,SAAQC,QAAR,QAAuB,sBAAvB;AACA,SAAQC,KAAR,QAAoB,wBAApB;AACA,SAAQC,UAAR,QAAyB,6BAAzB;AACA,SAAQC,WAAR,QAA0B,8BAA1B;AACA,SAAQC,+BAAR,QAA8C,mDAA9C;AACA,SAAQC,YAAR,QAA2B,8BAA3B;AACA,SAAQC,mBAAR,QAAkC,qCAAlC;AACA,SAAQC,KAAR,QAAoB,gCAApB;AACA,SAAQC,SAAR,QAAwB,oCAAxB;AACA,SAAQC,KAAR,QAAoB,gCAApB;AACA,SAAQC,6BAAR,QAA4C,kCAA5C;AACA,SAAQC,iBAAR,QAAgC,+BAAhC;AAEA,MAAMC,GAAG,GAAG,GAAGC,cAAf;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,YA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","sourcesContent":["/**\n * @typedef {import('micromark-util-types').Encoding} Encoding\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').ParseOptions} ParseOptions\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Value} Value\n *\n * @typedef {import('unist').Parent} UnistParent\n * @typedef {import('unist').Point} Point\n *\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n * @typedef {import('mdast').StaticPhrasingContent} StaticPhrasingContent\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').Break} Break\n * @typedef {import('mdast').Blockquote} Blockquote\n * @typedef {import('mdast').Code} Code\n * @typedef {import('mdast').Definition} Definition\n * @typedef {import('mdast').Emphasis} Emphasis\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('mdast').HTML} HTML\n * @typedef {import('mdast').Image} Image\n * @typedef {import('mdast').ImageReference} ImageReference\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('mdast').Link} Link\n * @typedef {import('mdast').LinkReference} LinkReference\n * @typedef {import('mdast').List} List\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').Strong} Strong\n * @typedef {import('mdast').Text} Text\n * @typedef {import('mdast').ThematicBreak} ThematicBreak\n * @typedef {import('mdast').ReferenceType} ReferenceType\n * @typedef {import('../index.js').CompileData} CompileData\n */\n\n/**\n * @typedef {Root | Content} Node\n * @typedef {Extract<Node, UnistParent>} Parent\n *\n * @typedef {Omit<UnistParent, 'type' | 'children'> & {type: 'fragment', children: Array<PhrasingContent>}} Fragment\n */\n\n/**\n * @callback Transform\n *   Extra transform, to change the AST afterwards.\n * @param {Root} tree\n *   Tree to transform.\n * @returns {Root | undefined | null | void}\n *   New tree or nothing (in which case the current tree is used).\n *\n * @callback Handle\n *   Handle a token.\n * @param {CompileContext} this\n *   Context.\n * @param {Token} token\n *   Current token.\n * @returns {void}\n *   Nothing.\n *\n * @typedef {Record<string, Handle>} Handles\n *   Token types mapping to handles\n *\n * @callback OnEnterError\n *   Handle the case where the `right` token is open, but it is closed (by the\n *   `left` token) or because we reached the end of the document.\n * @param {Omit<CompileContext, 'sliceSerialize'>} this\n *   Context.\n * @param {Token | undefined} left\n *   Left token.\n * @param {Token} right\n *   Right token.\n * @returns {void}\n *   Nothing.\n *\n * @callback OnExitError\n *   Handle the case where the `right` token is open but it is closed by\n *   exiting the `left` token.\n * @param {Omit<CompileContext, 'sliceSerialize'>} this\n *   Context.\n * @param {Token} left\n *   Left token.\n * @param {Token} right\n *   Right token.\n * @returns {void}\n *   Nothing.\n *\n * @typedef {[Token, OnEnterError | undefined]} TokenTuple\n *   Open token on the stack, with an optional error handler for when\n *   that token isn’t closed properly.\n */\n\n/**\n * @typedef Config\n *   Configuration.\n *\n *   We have our defaults, but extensions will add more.\n * @property {Array<string>} canContainEols\n *   Token types where line endings are used.\n * @property {Handles} enter\n *   Opening handles.\n * @property {Handles} exit\n *   Closing handles.\n * @property {Array<Transform>} transforms\n *   Tree transforms.\n *\n * @typedef {Partial<Config>} Extension\n *   Change how markdown tokens from micromark are turned into mdast.\n *\n * @typedef CompileContext\n *   mdast compiler context.\n * @property {Array<Node | Fragment>} stack\n *   Stack of nodes.\n * @property {Array<TokenTuple>} tokenStack\n *   Stack of tokens.\n * @property {<Key extends keyof CompileData>(key: Key) => CompileData[Key]} getData\n *   Get data from the key/value store.\n * @property {<Key extends keyof CompileData>(key: Key, value?: CompileData[Key]) => void} setData\n *   Set data into the key/value store.\n * @property {(this: CompileContext) => void} buffer\n *   Capture some of the output data.\n * @property {(this: CompileContext) => string} resume\n *   Stop capturing and access the output data.\n * @property {<Kind extends Node>(this: CompileContext, node: Kind, token: Token, onError?: OnEnterError) => Kind} enter\n *   Enter a token.\n * @property {(this: CompileContext, token: Token, onError?: OnExitError) => Node} exit\n *   Exit a token.\n * @property {TokenizeContext['sliceSerialize']} sliceSerialize\n *   Get the string value of a token.\n * @property {Config} config\n *   Configuration.\n *\n * @typedef FromMarkdownOptions\n *   Configuration for how to build mdast.\n * @property {Array<Extension | Array<Extension>> | null | undefined} [mdastExtensions]\n *   Extensions for this utility to change how tokens are turned into a tree.\n *\n * @typedef {ParseOptions & FromMarkdownOptions} Options\n *   Configuration.\n */\n\n// To do: micromark: create a registry of tokens?\n// To do: next major: don’t return given `Node` from `enter`.\n// To do: next major: remove setter/getter.\n\nimport {ok as assert} from 'uvu/assert'\nimport {toString} from 'mdast-util-to-string'\nimport {parse} from 'micromark/lib/parse.js'\nimport {preprocess} from 'micromark/lib/preprocess.js'\nimport {postprocess} from 'micromark/lib/postprocess.js'\nimport {decodeNumericCharacterReference} from 'micromark-util-decode-numeric-character-reference'\nimport {decodeString} from 'micromark-util-decode-string'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nimport {codes} from 'micromark-util-symbol/codes.js'\nimport {constants} from 'micromark-util-symbol/constants.js'\nimport {types} from 'micromark-util-symbol/types.js'\nimport {decodeNamedCharacterReference} from 'decode-named-character-reference'\nimport {stringifyPosition} from 'unist-util-stringify-position'\n\nconst own = {}.hasOwnProperty\n\n/**\n * @param value\n *   Markdown to parse.\n * @param encoding\n *   Character encoding for when `value` is `Buffer`.\n * @param options\n *   Configuration.\n * @returns\n *   mdast tree.\n */\nexport const fromMarkdown =\n  /**\n   * @type {(\n   *   ((value: Value, encoding: Encoding, options?: Options | null | undefined) => Root) &\n   *   ((value: Value, options?: Options | null | undefined) => Root)\n   * )}\n   */\n  (\n    /**\n     * @param {Value} value\n     * @param {Encoding | Options | null | undefined} [encoding]\n     * @param {Options | null | undefined} [options]\n     * @returns {Root}\n     */\n    function (value, encoding, options) {\n      if (typeof encoding !== 'string') {\n        options = encoding\n        encoding = undefined\n      }\n\n      return compiler(options)(\n        postprocess(\n          parse(options).document().write(preprocess()(value, encoding, true))\n        )\n      )\n    }\n  )\n\n/**\n * Note this compiler only understand complete buffering, not streaming.\n *\n * @param {Options | null | undefined} [options]\n */\nfunction compiler(options) {\n  /** @type {Config} */\n  const config = {\n    transforms: [],\n    canContainEols: ['emphasis', 'fragment', 'heading', 'paragraph', 'strong'],\n    enter: {\n      autolink: opener(link),\n      autolinkProtocol: onenterdata,\n      autolinkEmail: onenterdata,\n      atxHeading: opener(heading),\n      blockQuote: opener(blockQuote),\n      characterEscape: onenterdata,\n      characterReference: onenterdata,\n      codeFenced: opener(codeFlow),\n      codeFencedFenceInfo: buffer,\n      codeFencedFenceMeta: buffer,\n      codeIndented: opener(codeFlow, buffer),\n      codeText: opener(codeText, buffer),\n      codeTextData: onenterdata,\n      data: onenterdata,\n      codeFlowValue: onenterdata,\n      definition: opener(definition),\n      definitionDestinationString: buffer,\n      definitionLabelString: buffer,\n      definitionTitleString: buffer,\n      emphasis: opener(emphasis),\n      hardBreakEscape: opener(hardBreak),\n      hardBreakTrailing: opener(hardBreak),\n      htmlFlow: opener(html, buffer),\n      htmlFlowData: onenterdata,\n      htmlText: opener(html, buffer),\n      htmlTextData: onenterdata,\n      image: opener(image),\n      label: buffer,\n      link: opener(link),\n      listItem: opener(listItem),\n      listItemValue: onenterlistitemvalue,\n      listOrdered: opener(list, onenterlistordered),\n      listUnordered: opener(list),\n      paragraph: opener(paragraph),\n      reference: onenterreference,\n      referenceString: buffer,\n      resourceDestinationString: buffer,\n      resourceTitleString: buffer,\n      setextHeading: opener(heading),\n      strong: opener(strong),\n      thematicBreak: opener(thematicBreak)\n    },\n    exit: {\n      atxHeading: closer(),\n      atxHeadingSequence: onexitatxheadingsequence,\n      autolink: closer(),\n      autolinkEmail: onexitautolinkemail,\n      autolinkProtocol: onexitautolinkprotocol,\n      blockQuote: closer(),\n      characterEscapeValue: onexitdata,\n      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,\n      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,\n      characterReferenceValue: onexitcharacterreferencevalue,\n      codeFenced: closer(onexitcodefenced),\n      codeFencedFence: onexitcodefencedfence,\n      codeFencedFenceInfo: onexitcodefencedfenceinfo,\n      codeFencedFenceMeta: onexitcodefencedfencemeta,\n      codeFlowValue: onexitdata,\n      codeIndented: closer(onexitcodeindented),\n      codeText: closer(onexitcodetext),\n      codeTextData: onexitdata,\n      data: onexitdata,\n      definition: closer(),\n      definitionDestinationString: onexitdefinitiondestinationstring,\n      definitionLabelString: onexitdefinitionlabelstring,\n      definitionTitleString: onexitdefinitiontitlestring,\n      emphasis: closer(),\n      hardBreakEscape: closer(onexithardbreak),\n      hardBreakTrailing: closer(onexithardbreak),\n      htmlFlow: closer(onexithtmlflow),\n      htmlFlowData: onexitdata,\n      htmlText: closer(onexithtmltext),\n      htmlTextData: onexitdata,\n      image: closer(onexitimage),\n      label: onexitlabel,\n      labelText: onexitlabeltext,\n      lineEnding: onexitlineending,\n      link: closer(onexitlink),\n      listItem: closer(),\n      listOrdered: closer(),\n      listUnordered: closer(),\n      paragraph: closer(),\n      referenceString: onexitreferencestring,\n      resourceDestinationString: onexitresourcedestinationstring,\n      resourceTitleString: onexitresourcetitlestring,\n      resource: onexitresource,\n      setextHeading: closer(onexitsetextheading),\n      setextHeadingLineSequence: onexitsetextheadinglinesequence,\n      setextHeadingText: onexitsetextheadingtext,\n      strong: closer(),\n      thematicBreak: closer()\n    }\n  }\n\n  configure(config, (options || {}).mdastExtensions || [])\n\n  /** @type {CompileData} */\n  const data = {}\n\n  return compile\n\n  /**\n   * Turn micromark events into an mdast tree.\n   *\n   * @param {Array<Event>} events\n   *   Events.\n   * @returns {Root}\n   *   mdast tree.\n   */\n  function compile(events) {\n    /** @type {Root} */\n    let tree = {type: 'root', children: []}\n    /** @type {Omit<CompileContext, 'sliceSerialize'>} */\n    const context = {\n      stack: [tree],\n      tokenStack: [],\n      config,\n      enter,\n      exit,\n      buffer,\n      resume,\n      setData,\n      getData\n    }\n    /** @type {Array<number>} */\n    const listStack = []\n    let index = -1\n\n    while (++index < events.length) {\n      // We preprocess lists to add `listItem` tokens, and to infer whether\n      // items the list itself are spread out.\n      if (\n        events[index][1].type === types.listOrdered ||\n        events[index][1].type === types.listUnordered\n      ) {\n        if (events[index][0] === 'enter') {\n          listStack.push(index)\n        } else {\n          const tail = listStack.pop()\n          assert(typeof tail === 'number', 'expected list ot be open')\n          index = prepareList(events, tail, index)\n        }\n      }\n    }\n\n    index = -1\n\n    while (++index < events.length) {\n      const handler = config[events[index][0]]\n\n      if (own.call(handler, events[index][1].type)) {\n        handler[events[index][1].type].call(\n          Object.assign(\n            {sliceSerialize: events[index][2].sliceSerialize},\n            context\n          ),\n          events[index][1]\n        )\n      }\n    }\n\n    // Handle tokens still being open.\n    if (context.tokenStack.length > 0) {\n      const tail = context.tokenStack[context.tokenStack.length - 1]\n      const handler = tail[1] || defaultOnError\n      handler.call(context, undefined, tail[0])\n    }\n\n    // Figure out `root` position.\n    tree.position = {\n      start: point(\n        events.length > 0 ? events[0][1].start : {line: 1, column: 1, offset: 0}\n      ),\n      end: point(\n        events.length > 0\n          ? events[events.length - 2][1].end\n          : {line: 1, column: 1, offset: 0}\n      )\n    }\n\n    // Call transforms.\n    index = -1\n    while (++index < config.transforms.length) {\n      tree = config.transforms[index](tree) || tree\n    }\n\n    return tree\n  }\n\n  /**\n   * @param {Array<Event>} events\n   * @param {number} start\n   * @param {number} length\n   * @returns {number}\n   */\n  function prepareList(events, start, length) {\n    let index = start - 1\n    let containerBalance = -1\n    let listSpread = false\n    /** @type {Token | undefined} */\n    let listItem\n    /** @type {number | undefined} */\n    let lineIndex\n    /** @type {number | undefined} */\n    let firstBlankLineIndex\n    /** @type {boolean | undefined} */\n    let atMarker\n\n    while (++index <= length) {\n      const event = events[index]\n\n      if (\n        event[1].type === types.listUnordered ||\n        event[1].type === types.listOrdered ||\n        event[1].type === types.blockQuote\n      ) {\n        if (event[0] === 'enter') {\n          containerBalance++\n        } else {\n          containerBalance--\n        }\n\n        atMarker = undefined\n      } else if (event[1].type === types.lineEndingBlank) {\n        if (event[0] === 'enter') {\n          if (\n            listItem &&\n            !atMarker &&\n            !containerBalance &&\n            !firstBlankLineIndex\n          ) {\n            firstBlankLineIndex = index\n          }\n\n          atMarker = undefined\n        }\n      } else if (\n        event[1].type === types.linePrefix ||\n        event[1].type === types.listItemValue ||\n        event[1].type === types.listItemMarker ||\n        event[1].type === types.listItemPrefix ||\n        event[1].type === types.listItemPrefixWhitespace\n      ) {\n        // Empty.\n      } else {\n        atMarker = undefined\n      }\n\n      if (\n        (!containerBalance &&\n          event[0] === 'enter' &&\n          event[1].type === types.listItemPrefix) ||\n        (containerBalance === -1 &&\n          event[0] === 'exit' &&\n          (event[1].type === types.listUnordered ||\n            event[1].type === types.listOrdered))\n      ) {\n        if (listItem) {\n          let tailIndex = index\n          lineIndex = undefined\n\n          while (tailIndex--) {\n            const tailEvent = events[tailIndex]\n\n            if (\n              tailEvent[1].type === types.lineEnding ||\n              tailEvent[1].type === types.lineEndingBlank\n            ) {\n              if (tailEvent[0] === 'exit') continue\n\n              if (lineIndex) {\n                events[lineIndex][1].type = types.lineEndingBlank\n                listSpread = true\n              }\n\n              tailEvent[1].type = types.lineEnding\n              lineIndex = tailIndex\n            } else if (\n              tailEvent[1].type === types.linePrefix ||\n              tailEvent[1].type === types.blockQuotePrefix ||\n              tailEvent[1].type === types.blockQuotePrefixWhitespace ||\n              tailEvent[1].type === types.blockQuoteMarker ||\n              tailEvent[1].type === types.listItemIndent\n            ) {\n              // Empty\n            } else {\n              break\n            }\n          }\n\n          if (\n            firstBlankLineIndex &&\n            (!lineIndex || firstBlankLineIndex < lineIndex)\n          ) {\n            listItem._spread = true\n          }\n\n          // Fix position.\n          listItem.end = Object.assign(\n            {},\n            lineIndex ? events[lineIndex][1].start : event[1].end\n          )\n\n          events.splice(lineIndex || index, 0, ['exit', listItem, event[2]])\n          index++\n          length++\n        }\n\n        // Create a new list item.\n        if (event[1].type === types.listItemPrefix) {\n          listItem = {\n            type: 'listItem',\n            _spread: false,\n            start: Object.assign({}, event[1].start),\n            // @ts-expect-error: we’ll add `end` in a second.\n            end: undefined\n          }\n          // @ts-expect-error: `listItem` is most definitely defined, TS...\n          events.splice(index, 0, ['enter', listItem, event[2]])\n          index++\n          length++\n          firstBlankLineIndex = undefined\n          atMarker = true\n        }\n      }\n    }\n\n    events[start][1]._spread = listSpread\n    return length\n  }\n\n  /**\n   * Set data.\n   *\n   * @template {keyof CompileData} Key\n   *   Field type.\n   * @param {Key} key\n   *   Key of field.\n   * @param {CompileData[Key]} [value]\n   *   New value.\n   * @returns {void}\n   *   Nothing.\n   */\n  function setData(key, value) {\n    data[key] = value\n  }\n\n  /**\n   * Get data.\n   *\n   * @template {keyof CompileData} Key\n   *   Field type.\n   * @param {Key} key\n   *   Key of field.\n   * @returns {CompileData[Key]}\n   *   Value.\n   */\n  function getData(key) {\n    return data[key]\n  }\n\n  /**\n   * Create an opener handle.\n   *\n   * @param {(token: Token) => Node} create\n   *   Create a node.\n   * @param {Handle} [and]\n   *   Optional function to also run.\n   * @returns {Handle}\n   *   Handle.\n   */\n  function opener(create, and) {\n    return open\n\n    /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {void}\n     */\n    function open(token) {\n      enter.call(this, create(token), token)\n      if (and) and.call(this, token)\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @returns {void}\n   */\n  function buffer() {\n    this.stack.push({type: 'fragment', children: []})\n  }\n\n  /**\n   * @template {Node} Kind\n   *   Node type.\n   * @this {CompileContext}\n   *   Context.\n   * @param {Kind} node\n   *   Node to enter.\n   * @param {Token} token\n   *   Corresponding token.\n   * @param {OnEnterError | undefined} [errorHandler]\n   *   Handle the case where this token is open, but it is closed by something else.\n   * @returns {Kind}\n   *   The given node.\n   */\n  function enter(node, token, errorHandler) {\n    const parent = this.stack[this.stack.length - 1]\n    assert(parent, 'expected `parent`')\n    assert('children' in parent, 'expected `parent`')\n    // @ts-expect-error: Assume `Node` can exist as a child of `parent`.\n    parent.children.push(node)\n    this.stack.push(node)\n    this.tokenStack.push([token, errorHandler])\n    // @ts-expect-error: `end` will be patched later.\n    node.position = {start: point(token.start)}\n    return node\n  }\n\n  /**\n   * Create a closer handle.\n   *\n   * @param {Handle} [and]\n   *   Optional function to also run.\n   * @returns {Handle}\n   *   Handle.\n   */\n  function closer(and) {\n    return close\n\n    /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {void}\n     */\n    function close(token) {\n      if (and) and.call(this, token)\n      exit.call(this, token)\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   *   Context.\n   * @param {Token} token\n   *   Corresponding token.\n   * @param {OnExitError | undefined} [onExitError]\n   *   Handle the case where another token is open.\n   * @returns {Node}\n   *   The closed node.\n   */\n  function exit(token, onExitError) {\n    const node = this.stack.pop()\n    assert(node, 'expected `node`')\n    const open = this.tokenStack.pop()\n\n    if (!open) {\n      throw new Error(\n        'Cannot close `' +\n          token.type +\n          '` (' +\n          stringifyPosition({start: token.start, end: token.end}) +\n          '): it’s not open'\n      )\n    } else if (open[0].type !== token.type) {\n      if (onExitError) {\n        onExitError.call(this, token, open[0])\n      } else {\n        const handler = open[1] || defaultOnError\n        handler.call(this, token, open[0])\n      }\n    }\n\n    assert(node.type !== 'fragment', 'unexpected fragment `exit`ed')\n    assert(node.position, 'expected `position` to be defined')\n    node.position.end = point(token.end)\n    return node\n  }\n\n  /**\n   * @this {CompileContext}\n   * @returns {string}\n   */\n  function resume() {\n    return toString(this.stack.pop())\n  }\n\n  //\n  // Handlers.\n  //\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onenterlistordered() {\n    setData('expectingFirstListItemValue', true)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onenterlistitemvalue(token) {\n    if (getData('expectingFirstListItemValue')) {\n      const ancestor = this.stack[this.stack.length - 2]\n      assert(ancestor, 'expected nodes on stack')\n      assert(ancestor.type === 'list', 'expected list on stack')\n      ancestor.start = Number.parseInt(\n        this.sliceSerialize(token),\n        constants.numericBaseDecimal\n      )\n      setData('expectingFirstListItemValue')\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodefencedfenceinfo() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(node.type === 'code', 'expected code on stack')\n    node.lang = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodefencedfencemeta() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(node.type === 'code', 'expected code on stack')\n    node.meta = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodefencedfence() {\n    // Exit if this is the closing fence.\n    if (getData('flowCodeInside')) return\n    this.buffer()\n    setData('flowCodeInside', true)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodefenced() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(node.type === 'code', 'expected code on stack')\n\n    node.value = data.replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, '')\n    setData('flowCodeInside')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodeindented() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(node.type === 'code', 'expected code on stack')\n\n    node.value = data.replace(/(\\r?\\n|\\r)$/g, '')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitdefinitionlabelstring(token) {\n    const label = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(node.type === 'definition', 'expected definition on stack')\n\n    node.label = label\n    node.identifier = normalizeIdentifier(\n      this.sliceSerialize(token)\n    ).toLowerCase()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitdefinitiontitlestring() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(node.type === 'definition', 'expected definition on stack')\n\n    node.title = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitdefinitiondestinationstring() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(node.type === 'definition', 'expected definition on stack')\n\n    node.url = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitatxheadingsequence(token) {\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(node.type === 'heading', 'expected heading on stack')\n\n    if (!node.depth) {\n      const depth = this.sliceSerialize(token).length\n\n      assert(\n        depth === 1 ||\n          depth === 2 ||\n          depth === 3 ||\n          depth === 4 ||\n          depth === 5 ||\n          depth === 6,\n        'expected `depth` between `1` and `6`'\n      )\n\n      node.depth = depth\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitsetextheadingtext() {\n    setData('setextHeadingSlurpLineEnding', true)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitsetextheadinglinesequence(token) {\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(node.type === 'heading', 'expected heading on stack')\n\n    node.depth =\n      this.sliceSerialize(token).charCodeAt(0) === codes.equalsTo ? 1 : 2\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitsetextheading() {\n    setData('setextHeadingSlurpLineEnding')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onenterdata(token) {\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert('children' in node, 'expected parent on stack')\n\n    let tail = node.children[node.children.length - 1]\n\n    if (!tail || tail.type !== 'text') {\n      // Add a new text node.\n      tail = text()\n      // @ts-expect-error: we’ll add `end` later.\n      tail.position = {start: point(token.start)}\n      // @ts-expect-error: Assume `parent` accepts `text`.\n      node.children.push(tail)\n    }\n\n    this.stack.push(tail)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitdata(token) {\n    const tail = this.stack.pop()\n    assert(tail, 'expected a `node` to be on the stack')\n    assert('value' in tail, 'expected a `literal` to be on the stack')\n    assert(tail.position, 'expected `node` to have an open position')\n    tail.value += this.sliceSerialize(token)\n    tail.position.end = point(token.end)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitlineending(token) {\n    const context = this.stack[this.stack.length - 1]\n    assert(context, 'expected `node`')\n\n    // If we’re at a hard break, include the line ending in there.\n    if (getData('atHardBreak')) {\n      assert('children' in context, 'expected `parent`')\n      const tail = context.children[context.children.length - 1]\n      assert(tail.position, 'expected tail to have a starting position')\n      tail.position.end = point(token.end)\n      setData('atHardBreak')\n      return\n    }\n\n    if (\n      !getData('setextHeadingSlurpLineEnding') &&\n      config.canContainEols.includes(context.type)\n    ) {\n      onenterdata.call(this, token)\n      onexitdata.call(this, token)\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexithardbreak() {\n    setData('atHardBreak', true)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexithtmlflow() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(node.type === 'html', 'expected html on stack')\n\n    node.value = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexithtmltext() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(node.type === 'html', 'expected html on stack')\n\n    node.value = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitcodetext() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(node.type === 'inlineCode', 'expected inline code on stack')\n\n    node.value = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitlink() {\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(node.type === 'link', 'expected link on stack')\n\n    // Note: there are also `identifier` and `label` fields on this link node!\n    // These are used / cleaned here.\n\n    // To do: clean.\n    if (getData('inReference')) {\n      /** @type {ReferenceType} */\n      const referenceType = getData('referenceType') || 'shortcut'\n\n      node.type += 'Reference'\n      // @ts-expect-error: mutate.\n      node.referenceType = referenceType\n      // @ts-expect-error: mutate.\n      delete node.url\n      delete node.title\n    } else {\n      // @ts-expect-error: mutate.\n      delete node.identifier\n      // @ts-expect-error: mutate.\n      delete node.label\n    }\n\n    setData('referenceType')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitimage() {\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(node.type === 'image', 'expected image on stack')\n\n    // Note: there are also `identifier` and `label` fields on this link node!\n    // These are used / cleaned here.\n\n    // To do: clean.\n    if (getData('inReference')) {\n      /** @type {ReferenceType} */\n      const referenceType = getData('referenceType') || 'shortcut'\n\n      node.type += 'Reference'\n      // @ts-expect-error: mutate.\n      node.referenceType = referenceType\n      // @ts-expect-error: mutate.\n      delete node.url\n      delete node.title\n    } else {\n      // @ts-expect-error: mutate.\n      delete node.identifier\n      // @ts-expect-error: mutate.\n      delete node.label\n    }\n\n    setData('referenceType')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitlabeltext(token) {\n    const string = this.sliceSerialize(token)\n    const ancestor = this.stack[this.stack.length - 2]\n    assert(ancestor, 'expected ancestor on stack')\n    assert(\n      ancestor.type === 'image' || ancestor.type === 'link',\n      'expected image or link on stack'\n    )\n\n    // @ts-expect-error: stash this on the node, as it might become a reference\n    // later.\n    ancestor.label = decodeString(string)\n    // @ts-expect-error: same as above.\n    ancestor.identifier = normalizeIdentifier(string).toLowerCase()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitlabel() {\n    const fragment = this.stack[this.stack.length - 1]\n    assert(fragment, 'expected node on stack')\n    assert(fragment.type === 'fragment', 'expected fragment on stack')\n    const value = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(\n      node.type === 'image' || node.type === 'link',\n      'expected image or link on stack'\n    )\n\n    // Assume a reference.\n    setData('inReference', true)\n\n    if (node.type === 'link') {\n      /** @type {Array<StaticPhrasingContent>} */\n      // @ts-expect-error: Assume static phrasing content.\n      const children = fragment.children\n\n      node.children = children\n    } else {\n      node.alt = value\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitresourcedestinationstring() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(\n      node.type === 'image' || node.type === 'link',\n      'expected image or link on stack'\n    )\n    node.url = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitresourcetitlestring() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(\n      node.type === 'image' || node.type === 'link',\n      'expected image or link on stack'\n    )\n    node.title = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitresource() {\n    setData('inReference')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onenterreference() {\n    setData('referenceType', 'collapsed')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitreferencestring(token) {\n    const label = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(\n      node.type === 'image' || node.type === 'link',\n      'expected image reference or link reference on stack'\n    )\n\n    // @ts-expect-error: stash this on the node, as it might become a reference\n    // later.\n    node.label = label\n    // @ts-expect-error: same as above.\n    node.identifier = normalizeIdentifier(\n      this.sliceSerialize(token)\n    ).toLowerCase()\n    setData('referenceType', 'full')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitcharacterreferencemarker(token) {\n    assert(\n      token.type === 'characterReferenceMarkerNumeric' ||\n        token.type === 'characterReferenceMarkerHexadecimal'\n    )\n    setData('characterReferenceType', token.type)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcharacterreferencevalue(token) {\n    const data = this.sliceSerialize(token)\n    const type = getData('characterReferenceType')\n    /** @type {string} */\n    let value\n\n    if (type) {\n      value = decodeNumericCharacterReference(\n        data,\n        type === types.characterReferenceMarkerNumeric\n          ? constants.numericBaseDecimal\n          : constants.numericBaseHexadecimal\n      )\n      setData('characterReferenceType')\n    } else {\n      const result = decodeNamedCharacterReference(data)\n      assert(result !== false, 'expected reference to decode')\n      value = result\n    }\n\n    const tail = this.stack.pop()\n    assert(tail, 'expected `node`')\n    assert(tail.position, 'expected `node.position`')\n    assert('value' in tail, 'expected `node.value`')\n    tail.value += value\n    tail.position.end = point(token.end)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitautolinkprotocol(token) {\n    onexitdata.call(this, token)\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(node.type === 'link', 'expected link on stack')\n\n    node.url = this.sliceSerialize(token)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitautolinkemail(token) {\n    onexitdata.call(this, token)\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(node.type === 'link', 'expected link on stack')\n\n    node.url = 'mailto:' + this.sliceSerialize(token)\n  }\n\n  //\n  // Creaters.\n  //\n\n  /** @returns {Blockquote} */\n  function blockQuote() {\n    return {type: 'blockquote', children: []}\n  }\n\n  /** @returns {Code} */\n  function codeFlow() {\n    return {type: 'code', lang: null, meta: null, value: ''}\n  }\n\n  /** @returns {InlineCode} */\n  function codeText() {\n    return {type: 'inlineCode', value: ''}\n  }\n\n  /** @returns {Definition} */\n  function definition() {\n    return {\n      type: 'definition',\n      identifier: '',\n      label: null,\n      title: null,\n      url: ''\n    }\n  }\n\n  /** @returns {Emphasis} */\n  function emphasis() {\n    return {type: 'emphasis', children: []}\n  }\n\n  /** @returns {Heading} */\n  function heading() {\n    // @ts-expect-error `depth` will be set later.\n    return {type: 'heading', depth: undefined, children: []}\n  }\n\n  /** @returns {Break} */\n  function hardBreak() {\n    return {type: 'break'}\n  }\n\n  /** @returns {HTML} */\n  function html() {\n    return {type: 'html', value: ''}\n  }\n\n  /** @returns {Image} */\n  function image() {\n    return {type: 'image', title: null, url: '', alt: null}\n  }\n\n  /** @returns {Link} */\n  function link() {\n    return {type: 'link', title: null, url: '', children: []}\n  }\n\n  /**\n   * @param {Token} token\n   * @returns {List}\n   */\n  function list(token) {\n    return {\n      type: 'list',\n      ordered: token.type === 'listOrdered',\n      start: null,\n      spread: token._spread,\n      children: []\n    }\n  }\n\n  /**\n   * @param {Token} token\n   * @returns {ListItem}\n   */\n  function listItem(token) {\n    return {\n      type: 'listItem',\n      spread: token._spread,\n      checked: null,\n      children: []\n    }\n  }\n\n  /** @returns {Paragraph} */\n  function paragraph() {\n    return {type: 'paragraph', children: []}\n  }\n\n  /** @returns {Strong} */\n  function strong() {\n    return {type: 'strong', children: []}\n  }\n\n  /** @returns {Text} */\n  function text() {\n    return {type: 'text', value: ''}\n  }\n\n  /** @returns {ThematicBreak} */\n  function thematicBreak() {\n    return {type: 'thematicBreak'}\n  }\n}\n\n/**\n * Copy a point-like value.\n *\n * @param {Point} d\n *   Point-like value.\n * @returns {Point}\n *   unist point.\n */\nfunction point(d) {\n  return {line: d.line, column: d.column, offset: d.offset}\n}\n\n/**\n * @param {Config} combined\n * @param {Array<Extension | Array<Extension>>} extensions\n * @returns {void}\n */\nfunction configure(combined, extensions) {\n  let index = -1\n\n  while (++index < extensions.length) {\n    const value = extensions[index]\n\n    if (Array.isArray(value)) {\n      configure(combined, value)\n    } else {\n      extension(combined, value)\n    }\n  }\n}\n\n/**\n * @param {Config} combined\n * @param {Extension} extension\n * @returns {void}\n */\nfunction extension(combined, extension) {\n  /** @type {keyof Extension} */\n  let key\n\n  for (key in extension) {\n    if (own.call(extension, key)) {\n      if (key === 'canContainEols') {\n        const right = extension[key]\n        if (right) {\n          combined[key].push(...right)\n        }\n      } else if (key === 'transforms') {\n        const right = extension[key]\n        if (right) {\n          combined[key].push(...right)\n        }\n      } else if (key === 'enter' || key === 'exit') {\n        const right = extension[key]\n        if (right) {\n          Object.assign(combined[key], right)\n        }\n      }\n    }\n  }\n}\n\n/** @type {OnEnterError} */\nfunction defaultOnError(left, right) {\n  if (left) {\n    throw new Error(\n      'Cannot close `' +\n        left.type +\n        '` (' +\n        stringifyPosition({start: left.start, end: left.end}) +\n        '): a different token (`' +\n        right.type +\n        '`, ' +\n        stringifyPosition({start: right.start, end: right.end}) +\n        ') is open'\n    )\n  } else {\n    throw new Error(\n      'Cannot close document, a token (`' +\n        right.type +\n        '`, ' +\n        stringifyPosition({start: right.start, end: right.end}) +\n        ') is still open'\n    )\n  }\n}\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\nimport { factorySpace } from 'micromark-factory-space';\nimport { asciiAlpha, asciiAlphanumeric, markdownLineEnding, markdownLineEndingOrSpace, markdownSpace } from 'micromark-util-character';\nimport { codes } from 'micromark-util-symbol/codes.js';\nimport { constants } from 'micromark-util-symbol/constants.js';\nimport { types } from 'micromark-util-symbol/types.js';\nimport { ok as assert } from 'uvu/assert';\n/** @type {Construct} */\n\nexport const htmlText = {\n  name: 'htmlText',\n  tokenize: tokenizeHtmlText\n};\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\n\nfunction tokenizeHtmlText(effects, ok, nok) {\n  const self = this;\n  /** @type {NonNullable<Code> | undefined} */\n\n  let marker;\n  /** @type {number} */\n\n  let index;\n  /** @type {State} */\n\n  let returnState;\n  return start;\n  /**\n   * Start of HTML (text).\n   *\n   * ```markdown\n   * > | a <b> c\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n\n  function start(code) {\n    assert(code === codes.lessThan, 'expected `<`');\n    effects.enter(types.htmlText);\n    effects.enter(types.htmlTextData);\n    effects.consume(code);\n    return open;\n  }\n  /**\n   * After `<`, at tag name or other stuff.\n   *\n   * ```markdown\n   * > | a <b> c\n   *        ^\n   * > | a <!doctype> c\n   *        ^\n   * > | a <!--b--> c\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function open(code) {\n    if (code === codes.exclamationMark) {\n      effects.consume(code);\n      return declarationOpen;\n    }\n\n    if (code === codes.slash) {\n      effects.consume(code);\n      return tagCloseStart;\n    }\n\n    if (code === codes.questionMark) {\n      effects.consume(code);\n      return instruction;\n    } // ASCII alphabetical.\n\n\n    if (asciiAlpha(code)) {\n      effects.consume(code);\n      return tagOpen;\n    }\n\n    return nok(code);\n  }\n  /**\n   * After `<!`, at declaration, comment, or CDATA.\n   *\n   * ```markdown\n   * > | a <!doctype> c\n   *         ^\n   * > | a <!--b--> c\n   *         ^\n   * > | a <![CDATA[>&<]]> c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function declarationOpen(code) {\n    if (code === codes.dash) {\n      effects.consume(code);\n      return commentOpenInside;\n    }\n\n    if (code === codes.leftSquareBracket) {\n      effects.consume(code);\n      index = 0;\n      return cdataOpenInside;\n    }\n\n    if (asciiAlpha(code)) {\n      effects.consume(code);\n      return declaration;\n    }\n\n    return nok(code);\n  }\n  /**\n   * In a comment, after `<!-`, at another `-`.\n   *\n   * ```markdown\n   * > | a <!--b--> c\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function commentOpenInside(code) {\n    if (code === codes.dash) {\n      effects.consume(code);\n      return commentEnd;\n    }\n\n    return nok(code);\n  }\n  /**\n   * In comment.\n   *\n   * ```markdown\n   * > | a <!--b--> c\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function comment(code) {\n    if (code === codes.eof) {\n      return nok(code);\n    }\n\n    if (code === codes.dash) {\n      effects.consume(code);\n      return commentClose;\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = comment;\n      return lineEndingBefore(code);\n    }\n\n    effects.consume(code);\n    return comment;\n  }\n  /**\n   * In comment, after `-`.\n   *\n   * ```markdown\n   * > | a <!--b--> c\n   *             ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function commentClose(code) {\n    if (code === codes.dash) {\n      effects.consume(code);\n      return commentEnd;\n    }\n\n    return comment(code);\n  }\n  /**\n   * In comment, after `--`.\n   *\n   * ```markdown\n   * > | a <!--b--> c\n   *              ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function commentEnd(code) {\n    return code === codes.greaterThan ? end(code) : code === codes.dash ? commentClose(code) : comment(code);\n  }\n  /**\n   * After `<![`, in CDATA, expecting `CDATA[`.\n   *\n   * ```markdown\n   * > | a <![CDATA[>&<]]> b\n   *          ^^^^^^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function cdataOpenInside(code) {\n    const value = constants.cdataOpeningString;\n\n    if (code === value.charCodeAt(index++)) {\n      effects.consume(code);\n      return index === value.length ? cdata : cdataOpenInside;\n    }\n\n    return nok(code);\n  }\n  /**\n   * In CDATA.\n   *\n   * ```markdown\n   * > | a <![CDATA[>&<]]> b\n   *                ^^^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function cdata(code) {\n    if (code === codes.eof) {\n      return nok(code);\n    }\n\n    if (code === codes.rightSquareBracket) {\n      effects.consume(code);\n      return cdataClose;\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = cdata;\n      return lineEndingBefore(code);\n    }\n\n    effects.consume(code);\n    return cdata;\n  }\n  /**\n   * In CDATA, after `]`, at another `]`.\n   *\n   * ```markdown\n   * > | a <![CDATA[>&<]]> b\n   *                    ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function cdataClose(code) {\n    if (code === codes.rightSquareBracket) {\n      effects.consume(code);\n      return cdataEnd;\n    }\n\n    return cdata(code);\n  }\n  /**\n   * In CDATA, after `]]`, at `>`.\n   *\n   * ```markdown\n   * > | a <![CDATA[>&<]]> b\n   *                     ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function cdataEnd(code) {\n    if (code === codes.greaterThan) {\n      return end(code);\n    }\n\n    if (code === codes.rightSquareBracket) {\n      effects.consume(code);\n      return cdataEnd;\n    }\n\n    return cdata(code);\n  }\n  /**\n   * In declaration.\n   *\n   * ```markdown\n   * > | a <!b> c\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function declaration(code) {\n    if (code === codes.eof || code === codes.greaterThan) {\n      return end(code);\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = declaration;\n      return lineEndingBefore(code);\n    }\n\n    effects.consume(code);\n    return declaration;\n  }\n  /**\n   * In instruction.\n   *\n   * ```markdown\n   * > | a <?b?> c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function instruction(code) {\n    if (code === codes.eof) {\n      return nok(code);\n    }\n\n    if (code === codes.questionMark) {\n      effects.consume(code);\n      return instructionClose;\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = instruction;\n      return lineEndingBefore(code);\n    }\n\n    effects.consume(code);\n    return instruction;\n  }\n  /**\n   * In instruction, after `?`, at `>`.\n   *\n   * ```markdown\n   * > | a <?b?> c\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function instructionClose(code) {\n    return code === codes.greaterThan ? end(code) : instruction(code);\n  }\n  /**\n   * After `</`, in closing tag, at tag name.\n   *\n   * ```markdown\n   * > | a </b> c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function tagCloseStart(code) {\n    // ASCII alphabetical.\n    if (asciiAlpha(code)) {\n      effects.consume(code);\n      return tagClose;\n    }\n\n    return nok(code);\n  }\n  /**\n   * After `</x`, in a tag name.\n   *\n   * ```markdown\n   * > | a </b> c\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function tagClose(code) {\n    // ASCII alphanumerical and `-`.\n    if (code === codes.dash || asciiAlphanumeric(code)) {\n      effects.consume(code);\n      return tagClose;\n    }\n\n    return tagCloseBetween(code);\n  }\n  /**\n   * In closing tag, after tag name.\n   *\n   * ```markdown\n   * > | a </b> c\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function tagCloseBetween(code) {\n    if (markdownLineEnding(code)) {\n      returnState = tagCloseBetween;\n      return lineEndingBefore(code);\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return tagCloseBetween;\n    }\n\n    return end(code);\n  }\n  /**\n   * After `<x`, in opening tag name.\n   *\n   * ```markdown\n   * > | a <b> c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function tagOpen(code) {\n    // ASCII alphanumerical and `-`.\n    if (code === codes.dash || asciiAlphanumeric(code)) {\n      effects.consume(code);\n      return tagOpen;\n    }\n\n    if (code === codes.slash || code === codes.greaterThan || markdownLineEndingOrSpace(code)) {\n      return tagOpenBetween(code);\n    }\n\n    return nok(code);\n  }\n  /**\n   * In opening tag, after tag name.\n   *\n   * ```markdown\n   * > | a <b> c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function tagOpenBetween(code) {\n    if (code === codes.slash) {\n      effects.consume(code);\n      return end;\n    } // ASCII alphabetical and `:` and `_`.\n\n\n    if (code === codes.colon || code === codes.underscore || asciiAlpha(code)) {\n      effects.consume(code);\n      return tagOpenAttributeName;\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenBetween;\n      return lineEndingBefore(code);\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return tagOpenBetween;\n    }\n\n    return end(code);\n  }\n  /**\n   * In attribute name.\n   *\n   * ```markdown\n   * > | a <b c> d\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function tagOpenAttributeName(code) {\n    // ASCII alphabetical and `-`, `.`, `:`, and `_`.\n    if (code === codes.dash || code === codes.dot || code === codes.colon || code === codes.underscore || asciiAlphanumeric(code)) {\n      effects.consume(code);\n      return tagOpenAttributeName;\n    }\n\n    return tagOpenAttributeNameAfter(code);\n  }\n  /**\n   * After attribute name, before initializer, the end of the tag, or\n   * whitespace.\n   *\n   * ```markdown\n   * > | a <b c> d\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function tagOpenAttributeNameAfter(code) {\n    if (code === codes.equalsTo) {\n      effects.consume(code);\n      return tagOpenAttributeValueBefore;\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenAttributeNameAfter;\n      return lineEndingBefore(code);\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return tagOpenAttributeNameAfter;\n    }\n\n    return tagOpenBetween(code);\n  }\n  /**\n   * Before unquoted, double quoted, or single quoted attribute value, allowing\n   * whitespace.\n   *\n   * ```markdown\n   * > | a <b c=d> e\n   *            ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function tagOpenAttributeValueBefore(code) {\n    if (code === codes.eof || code === codes.lessThan || code === codes.equalsTo || code === codes.greaterThan || code === codes.graveAccent) {\n      return nok(code);\n    }\n\n    if (code === codes.quotationMark || code === codes.apostrophe) {\n      effects.consume(code);\n      marker = code;\n      return tagOpenAttributeValueQuoted;\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenAttributeValueBefore;\n      return lineEndingBefore(code);\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return tagOpenAttributeValueBefore;\n    }\n\n    effects.consume(code);\n    return tagOpenAttributeValueUnquoted;\n  }\n  /**\n   * In double or single quoted attribute value.\n   *\n   * ```markdown\n   * > | a <b c=\"d\"> e\n   *             ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function tagOpenAttributeValueQuoted(code) {\n    if (code === marker) {\n      effects.consume(code);\n      marker = undefined;\n      return tagOpenAttributeValueQuotedAfter;\n    }\n\n    if (code === codes.eof) {\n      return nok(code);\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenAttributeValueQuoted;\n      return lineEndingBefore(code);\n    }\n\n    effects.consume(code);\n    return tagOpenAttributeValueQuoted;\n  }\n  /**\n   * In unquoted attribute value.\n   *\n   * ```markdown\n   * > | a <b c=d> e\n   *            ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function tagOpenAttributeValueUnquoted(code) {\n    if (code === codes.eof || code === codes.quotationMark || code === codes.apostrophe || code === codes.lessThan || code === codes.equalsTo || code === codes.graveAccent) {\n      return nok(code);\n    }\n\n    if (code === codes.slash || code === codes.greaterThan || markdownLineEndingOrSpace(code)) {\n      return tagOpenBetween(code);\n    }\n\n    effects.consume(code);\n    return tagOpenAttributeValueUnquoted;\n  }\n  /**\n   * After double or single quoted attribute value, before whitespace or the end\n   * of the tag.\n   *\n   * ```markdown\n   * > | a <b c=\"d\"> e\n   *               ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function tagOpenAttributeValueQuotedAfter(code) {\n    if (code === codes.slash || code === codes.greaterThan || markdownLineEndingOrSpace(code)) {\n      return tagOpenBetween(code);\n    }\n\n    return nok(code);\n  }\n  /**\n   * In certain circumstances of a tag where only an `>` is allowed.\n   *\n   * ```markdown\n   * > | a <b c=\"d\"> e\n   *               ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function end(code) {\n    if (code === codes.greaterThan) {\n      effects.consume(code);\n      effects.exit(types.htmlTextData);\n      effects.exit(types.htmlText);\n      return ok;\n    }\n\n    return nok(code);\n  }\n  /**\n   * At eol.\n   *\n   * > ðŸ‘‰ **Note**: we canâ€™t have blank lines in text, so no need to worry about\n   * > empty tokens.\n   *\n   * ```markdown\n   * > | a <!--a\n   *            ^\n   *   | b-->\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function lineEndingBefore(code) {\n    assert(returnState, 'expected return state');\n    assert(markdownLineEnding(code), 'expected eol');\n    effects.exit(types.htmlTextData);\n    effects.enter(types.lineEnding);\n    effects.consume(code);\n    effects.exit(types.lineEnding);\n    return lineEndingAfter;\n  }\n  /**\n   * After eol, at optional whitespace.\n   *\n   * > ðŸ‘‰ **Note**: we canâ€™t have blank lines in text, so no need to worry about\n   * > empty tokens.\n   *\n   * ```markdown\n   *   | a <!--a\n   * > | b-->\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function lineEndingAfter(code) {\n    // Always populated by defaults.\n    assert(self.parser.constructs.disable.null, 'expected `disable.null` to be populated');\n    return markdownSpace(code) ? factorySpace(effects, lineEndingAfterPrefix, types.linePrefix, self.parser.constructs.disable.null.includes('codeIndented') ? undefined : constants.tabSize)(code) : lineEndingAfterPrefix(code);\n  }\n  /**\n   * After eol, after optional whitespace.\n   *\n   * > ðŸ‘‰ **Note**: we canâ€™t have blank lines in text, so no need to worry about\n   * > empty tokens.\n   *\n   * ```markdown\n   *   | a <!--a\n   * > | b-->\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function lineEndingAfterPrefix(code) {\n    effects.enter(types.htmlTextData);\n    return returnState(code);\n  }\n}","map":{"version":3,"sources":["D:/com lab/react/keerthana/auth2/AuthInMern/client/node_modules/micromark-core-commonmark/dev/lib/html-text.js"],"names":["factorySpace","asciiAlpha","asciiAlphanumeric","markdownLineEnding","markdownLineEndingOrSpace","markdownSpace","codes","constants","types","ok","assert","htmlText","name","tokenize","tokenizeHtmlText","effects","nok","self","marker","index","returnState","start","code","lessThan","enter","htmlTextData","consume","open","exclamationMark","declarationOpen","slash","tagCloseStart","questionMark","instruction","tagOpen","dash","commentOpenInside","leftSquareBracket","cdataOpenInside","declaration","commentEnd","comment","eof","commentClose","lineEndingBefore","greaterThan","end","value","cdataOpeningString","charCodeAt","length","cdata","rightSquareBracket","cdataClose","cdataEnd","instructionClose","tagClose","tagCloseBetween","tagOpenBetween","colon","underscore","tagOpenAttributeName","dot","tagOpenAttributeNameAfter","equalsTo","tagOpenAttributeValueBefore","graveAccent","quotationMark","apostrophe","tagOpenAttributeValueQuoted","tagOpenAttributeValueUnquoted","undefined","tagOpenAttributeValueQuotedAfter","exit","lineEnding","lineEndingAfter","parser","constructs","disable","null","lineEndingAfterPrefix","linePrefix","includes","tabSize"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {\n  asciiAlpha,\n  asciiAlphanumeric,\n  markdownLineEnding,\n  markdownLineEndingOrSpace,\n  markdownSpace\n} from 'micromark-util-character'\nimport {codes} from 'micromark-util-symbol/codes.js'\nimport {constants} from 'micromark-util-symbol/constants.js'\nimport {types} from 'micromark-util-symbol/types.js'\nimport {ok as assert} from 'uvu/assert'\n\n/** @type {Construct} */\nexport const htmlText = {name: 'htmlText', tokenize: tokenizeHtmlText}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeHtmlText(effects, ok, nok) {\n  const self = this\n  /** @type {NonNullable<Code> | undefined} */\n  let marker\n  /** @type {number} */\n  let index\n  /** @type {State} */\n  let returnState\n\n  return start\n\n  /**\n   * Start of HTML (text).\n   *\n   * ```markdown\n   * > | a <b> c\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    assert(code === codes.lessThan, 'expected `<`')\n    effects.enter(types.htmlText)\n    effects.enter(types.htmlTextData)\n    effects.consume(code)\n    return open\n  }\n\n  /**\n   * After `<`, at tag name or other stuff.\n   *\n   * ```markdown\n   * > | a <b> c\n   *        ^\n   * > | a <!doctype> c\n   *        ^\n   * > | a <!--b--> c\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function open(code) {\n    if (code === codes.exclamationMark) {\n      effects.consume(code)\n      return declarationOpen\n    }\n\n    if (code === codes.slash) {\n      effects.consume(code)\n      return tagCloseStart\n    }\n\n    if (code === codes.questionMark) {\n      effects.consume(code)\n      return instruction\n    }\n\n    // ASCII alphabetical.\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      return tagOpen\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * After `<!`, at declaration, comment, or CDATA.\n   *\n   * ```markdown\n   * > | a <!doctype> c\n   *         ^\n   * > | a <!--b--> c\n   *         ^\n   * > | a <![CDATA[>&<]]> c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function declarationOpen(code) {\n    if (code === codes.dash) {\n      effects.consume(code)\n      return commentOpenInside\n    }\n\n    if (code === codes.leftSquareBracket) {\n      effects.consume(code)\n      index = 0\n      return cdataOpenInside\n    }\n\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      return declaration\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * In a comment, after `<!-`, at another `-`.\n   *\n   * ```markdown\n   * > | a <!--b--> c\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function commentOpenInside(code) {\n    if (code === codes.dash) {\n      effects.consume(code)\n      return commentEnd\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * In comment.\n   *\n   * ```markdown\n   * > | a <!--b--> c\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function comment(code) {\n    if (code === codes.eof) {\n      return nok(code)\n    }\n\n    if (code === codes.dash) {\n      effects.consume(code)\n      return commentClose\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = comment\n      return lineEndingBefore(code)\n    }\n\n    effects.consume(code)\n    return comment\n  }\n\n  /**\n   * In comment, after `-`.\n   *\n   * ```markdown\n   * > | a <!--b--> c\n   *             ^\n   * ```\n   *\n   * @type {State}\n   */\n  function commentClose(code) {\n    if (code === codes.dash) {\n      effects.consume(code)\n      return commentEnd\n    }\n\n    return comment(code)\n  }\n\n  /**\n   * In comment, after `--`.\n   *\n   * ```markdown\n   * > | a <!--b--> c\n   *              ^\n   * ```\n   *\n   * @type {State}\n   */\n  function commentEnd(code) {\n    return code === codes.greaterThan\n      ? end(code)\n      : code === codes.dash\n      ? commentClose(code)\n      : comment(code)\n  }\n\n  /**\n   * After `<![`, in CDATA, expecting `CDATA[`.\n   *\n   * ```markdown\n   * > | a <![CDATA[>&<]]> b\n   *          ^^^^^^\n   * ```\n   *\n   * @type {State}\n   */\n  function cdataOpenInside(code) {\n    const value = constants.cdataOpeningString\n\n    if (code === value.charCodeAt(index++)) {\n      effects.consume(code)\n      return index === value.length ? cdata : cdataOpenInside\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * In CDATA.\n   *\n   * ```markdown\n   * > | a <![CDATA[>&<]]> b\n   *                ^^^\n   * ```\n   *\n   * @type {State}\n   */\n  function cdata(code) {\n    if (code === codes.eof) {\n      return nok(code)\n    }\n\n    if (code === codes.rightSquareBracket) {\n      effects.consume(code)\n      return cdataClose\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = cdata\n      return lineEndingBefore(code)\n    }\n\n    effects.consume(code)\n    return cdata\n  }\n\n  /**\n   * In CDATA, after `]`, at another `]`.\n   *\n   * ```markdown\n   * > | a <![CDATA[>&<]]> b\n   *                    ^\n   * ```\n   *\n   * @type {State}\n   */\n  function cdataClose(code) {\n    if (code === codes.rightSquareBracket) {\n      effects.consume(code)\n      return cdataEnd\n    }\n\n    return cdata(code)\n  }\n\n  /**\n   * In CDATA, after `]]`, at `>`.\n   *\n   * ```markdown\n   * > | a <![CDATA[>&<]]> b\n   *                     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function cdataEnd(code) {\n    if (code === codes.greaterThan) {\n      return end(code)\n    }\n\n    if (code === codes.rightSquareBracket) {\n      effects.consume(code)\n      return cdataEnd\n    }\n\n    return cdata(code)\n  }\n\n  /**\n   * In declaration.\n   *\n   * ```markdown\n   * > | a <!b> c\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function declaration(code) {\n    if (code === codes.eof || code === codes.greaterThan) {\n      return end(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = declaration\n      return lineEndingBefore(code)\n    }\n\n    effects.consume(code)\n    return declaration\n  }\n\n  /**\n   * In instruction.\n   *\n   * ```markdown\n   * > | a <?b?> c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function instruction(code) {\n    if (code === codes.eof) {\n      return nok(code)\n    }\n\n    if (code === codes.questionMark) {\n      effects.consume(code)\n      return instructionClose\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = instruction\n      return lineEndingBefore(code)\n    }\n\n    effects.consume(code)\n    return instruction\n  }\n\n  /**\n   * In instruction, after `?`, at `>`.\n   *\n   * ```markdown\n   * > | a <?b?> c\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function instructionClose(code) {\n    return code === codes.greaterThan ? end(code) : instruction(code)\n  }\n\n  /**\n   * After `</`, in closing tag, at tag name.\n   *\n   * ```markdown\n   * > | a </b> c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagCloseStart(code) {\n    // ASCII alphabetical.\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      return tagClose\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * After `</x`, in a tag name.\n   *\n   * ```markdown\n   * > | a </b> c\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagClose(code) {\n    // ASCII alphanumerical and `-`.\n    if (code === codes.dash || asciiAlphanumeric(code)) {\n      effects.consume(code)\n      return tagClose\n    }\n\n    return tagCloseBetween(code)\n  }\n\n  /**\n   * In closing tag, after tag name.\n   *\n   * ```markdown\n   * > | a </b> c\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagCloseBetween(code) {\n    if (markdownLineEnding(code)) {\n      returnState = tagCloseBetween\n      return lineEndingBefore(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return tagCloseBetween\n    }\n\n    return end(code)\n  }\n\n  /**\n   * After `<x`, in opening tag name.\n   *\n   * ```markdown\n   * > | a <b> c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagOpen(code) {\n    // ASCII alphanumerical and `-`.\n    if (code === codes.dash || asciiAlphanumeric(code)) {\n      effects.consume(code)\n      return tagOpen\n    }\n\n    if (\n      code === codes.slash ||\n      code === codes.greaterThan ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      return tagOpenBetween(code)\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * In opening tag, after tag name.\n   *\n   * ```markdown\n   * > | a <b> c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagOpenBetween(code) {\n    if (code === codes.slash) {\n      effects.consume(code)\n      return end\n    }\n\n    // ASCII alphabetical and `:` and `_`.\n    if (code === codes.colon || code === codes.underscore || asciiAlpha(code)) {\n      effects.consume(code)\n      return tagOpenAttributeName\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenBetween\n      return lineEndingBefore(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return tagOpenBetween\n    }\n\n    return end(code)\n  }\n\n  /**\n   * In attribute name.\n   *\n   * ```markdown\n   * > | a <b c> d\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagOpenAttributeName(code) {\n    // ASCII alphabetical and `-`, `.`, `:`, and `_`.\n    if (\n      code === codes.dash ||\n      code === codes.dot ||\n      code === codes.colon ||\n      code === codes.underscore ||\n      asciiAlphanumeric(code)\n    ) {\n      effects.consume(code)\n      return tagOpenAttributeName\n    }\n\n    return tagOpenAttributeNameAfter(code)\n  }\n\n  /**\n   * After attribute name, before initializer, the end of the tag, or\n   * whitespace.\n   *\n   * ```markdown\n   * > | a <b c> d\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagOpenAttributeNameAfter(code) {\n    if (code === codes.equalsTo) {\n      effects.consume(code)\n      return tagOpenAttributeValueBefore\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenAttributeNameAfter\n      return lineEndingBefore(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return tagOpenAttributeNameAfter\n    }\n\n    return tagOpenBetween(code)\n  }\n\n  /**\n   * Before unquoted, double quoted, or single quoted attribute value, allowing\n   * whitespace.\n   *\n   * ```markdown\n   * > | a <b c=d> e\n   *            ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagOpenAttributeValueBefore(code) {\n    if (\n      code === codes.eof ||\n      code === codes.lessThan ||\n      code === codes.equalsTo ||\n      code === codes.greaterThan ||\n      code === codes.graveAccent\n    ) {\n      return nok(code)\n    }\n\n    if (code === codes.quotationMark || code === codes.apostrophe) {\n      effects.consume(code)\n      marker = code\n      return tagOpenAttributeValueQuoted\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenAttributeValueBefore\n      return lineEndingBefore(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return tagOpenAttributeValueBefore\n    }\n\n    effects.consume(code)\n    return tagOpenAttributeValueUnquoted\n  }\n\n  /**\n   * In double or single quoted attribute value.\n   *\n   * ```markdown\n   * > | a <b c=\"d\"> e\n   *             ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagOpenAttributeValueQuoted(code) {\n    if (code === marker) {\n      effects.consume(code)\n      marker = undefined\n      return tagOpenAttributeValueQuotedAfter\n    }\n\n    if (code === codes.eof) {\n      return nok(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenAttributeValueQuoted\n      return lineEndingBefore(code)\n    }\n\n    effects.consume(code)\n    return tagOpenAttributeValueQuoted\n  }\n\n  /**\n   * In unquoted attribute value.\n   *\n   * ```markdown\n   * > | a <b c=d> e\n   *            ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagOpenAttributeValueUnquoted(code) {\n    if (\n      code === codes.eof ||\n      code === codes.quotationMark ||\n      code === codes.apostrophe ||\n      code === codes.lessThan ||\n      code === codes.equalsTo ||\n      code === codes.graveAccent\n    ) {\n      return nok(code)\n    }\n\n    if (\n      code === codes.slash ||\n      code === codes.greaterThan ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      return tagOpenBetween(code)\n    }\n\n    effects.consume(code)\n    return tagOpenAttributeValueUnquoted\n  }\n\n  /**\n   * After double or single quoted attribute value, before whitespace or the end\n   * of the tag.\n   *\n   * ```markdown\n   * > | a <b c=\"d\"> e\n   *               ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagOpenAttributeValueQuotedAfter(code) {\n    if (\n      code === codes.slash ||\n      code === codes.greaterThan ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      return tagOpenBetween(code)\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * In certain circumstances of a tag where only an `>` is allowed.\n   *\n   * ```markdown\n   * > | a <b c=\"d\"> e\n   *               ^\n   * ```\n   *\n   * @type {State}\n   */\n  function end(code) {\n    if (code === codes.greaterThan) {\n      effects.consume(code)\n      effects.exit(types.htmlTextData)\n      effects.exit(types.htmlText)\n      return ok\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * At eol.\n   *\n   * > ðŸ‘‰ **Note**: we canâ€™t have blank lines in text, so no need to worry about\n   * > empty tokens.\n   *\n   * ```markdown\n   * > | a <!--a\n   *            ^\n   *   | b-->\n   * ```\n   *\n   * @type {State}\n   */\n  function lineEndingBefore(code) {\n    assert(returnState, 'expected return state')\n    assert(markdownLineEnding(code), 'expected eol')\n    effects.exit(types.htmlTextData)\n    effects.enter(types.lineEnding)\n    effects.consume(code)\n    effects.exit(types.lineEnding)\n    return lineEndingAfter\n  }\n\n  /**\n   * After eol, at optional whitespace.\n   *\n   * > ðŸ‘‰ **Note**: we canâ€™t have blank lines in text, so no need to worry about\n   * > empty tokens.\n   *\n   * ```markdown\n   *   | a <!--a\n   * > | b-->\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function lineEndingAfter(code) {\n    // Always populated by defaults.\n    assert(\n      self.parser.constructs.disable.null,\n      'expected `disable.null` to be populated'\n    )\n    return markdownSpace(code)\n      ? factorySpace(\n          effects,\n          lineEndingAfterPrefix,\n          types.linePrefix,\n          self.parser.constructs.disable.null.includes('codeIndented')\n            ? undefined\n            : constants.tabSize\n        )(code)\n      : lineEndingAfterPrefix(code)\n  }\n\n  /**\n   * After eol, after optional whitespace.\n   *\n   * > ðŸ‘‰ **Note**: we canâ€™t have blank lines in text, so no need to worry about\n   * > empty tokens.\n   *\n   * ```markdown\n   *   | a <!--a\n   * > | b-->\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function lineEndingAfterPrefix(code) {\n    effects.enter(types.htmlTextData)\n    return returnState(code)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\nimport { asciiAlpha, asciiAlphanumeric, markdownLineEnding, markdownLineEndingOrSpace, markdownSpace } from 'micromark-util-character';\nimport { htmlBlockNames, htmlRawNames } from 'micromark-util-html-tag-name';\nimport { codes } from 'micromark-util-symbol/codes.js';\nimport { constants } from 'micromark-util-symbol/constants.js';\nimport { types } from 'micromark-util-symbol/types.js';\nimport { ok as assert } from 'uvu/assert';\nimport { blankLine } from './blank-line.js';\n/** @type {Construct} */\n\nexport const htmlFlow = {\n  name: 'htmlFlow',\n  tokenize: tokenizeHtmlFlow,\n  resolveTo: resolveToHtmlFlow,\n  concrete: true\n};\n/** @type {Construct} */\n\nconst blankLineBefore = {\n  tokenize: tokenizeBlankLineBefore,\n  partial: true\n};\nconst nonLazyContinuationStart = {\n  tokenize: tokenizeNonLazyContinuationStart,\n  partial: true\n};\n/** @type {Resolver} */\n\nfunction resolveToHtmlFlow(events) {\n  let index = events.length;\n\n  while (index--) {\n    if (events[index][0] === 'enter' && events[index][1].type === types.htmlFlow) {\n      break;\n    }\n  }\n\n  if (index > 1 && events[index - 2][1].type === types.linePrefix) {\n    // Add the prefix start to the HTML token.\n    events[index][1].start = events[index - 2][1].start; // Add the prefix start to the HTML line token.\n\n    events[index + 1][1].start = events[index - 2][1].start; // Remove the line prefix.\n\n    events.splice(index - 2, 2);\n  }\n\n  return events;\n}\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\n\n\nfunction tokenizeHtmlFlow(effects, ok, nok) {\n  const self = this;\n  /** @type {number} */\n\n  let marker;\n  /** @type {boolean} */\n\n  let closingTag;\n  /** @type {string} */\n\n  let buffer;\n  /** @type {number} */\n\n  let index;\n  /** @type {Code} */\n\n  let markerB;\n  return start;\n  /**\n   * Start of HTML (flow).\n   *\n   * ```markdown\n   * > | <x />\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n\n  function start(code) {\n    // To do: parse indent like `markdown-rs`.\n    return before(code);\n  }\n  /**\n   * At `<`, after optional whitespace.\n   *\n   * ```markdown\n   * > | <x />\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function before(code) {\n    assert(code === codes.lessThan, 'expected `<`');\n    effects.enter(types.htmlFlow);\n    effects.enter(types.htmlFlowData);\n    effects.consume(code);\n    return open;\n  }\n  /**\n   * After `<`, at tag name or other stuff.\n   *\n   * ```markdown\n   * > | <x />\n   *      ^\n   * > | <!doctype>\n   *      ^\n   * > | <!--xxx-->\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function open(code) {\n    if (code === codes.exclamationMark) {\n      effects.consume(code);\n      return declarationOpen;\n    }\n\n    if (code === codes.slash) {\n      effects.consume(code);\n      closingTag = true;\n      return tagCloseStart;\n    }\n\n    if (code === codes.questionMark) {\n      effects.consume(code);\n      marker = constants.htmlInstruction; // To do:\n      // tokenizer.concrete = true\n      // To do: use `markdown-rs` style interrupt.\n      // While we’re in an instruction instead of a declaration, we’re on a `?`\n      // right now, so we do need to search for `>`, similar to declarations.\n\n      return self.interrupt ? ok : continuationDeclarationInside;\n    } // ASCII alphabetical.\n\n\n    if (asciiAlpha(code)) {\n      effects.consume(code); // @ts-expect-error: not null.\n\n      buffer = String.fromCharCode(code);\n      return tagName;\n    }\n\n    return nok(code);\n  }\n  /**\n   * After `<!`, at declaration, comment, or CDATA.\n   *\n   * ```markdown\n   * > | <!doctype>\n   *       ^\n   * > | <!--xxx-->\n   *       ^\n   * > | <![CDATA[>&<]]>\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function declarationOpen(code) {\n    if (code === codes.dash) {\n      effects.consume(code);\n      marker = constants.htmlComment;\n      return commentOpenInside;\n    }\n\n    if (code === codes.leftSquareBracket) {\n      effects.consume(code);\n      marker = constants.htmlCdata;\n      index = 0;\n      return cdataOpenInside;\n    } // ASCII alphabetical.\n\n\n    if (asciiAlpha(code)) {\n      effects.consume(code);\n      marker = constants.htmlDeclaration; // // Do not form containers.\n      // tokenizer.concrete = true\n\n      return self.interrupt ? ok : continuationDeclarationInside;\n    }\n\n    return nok(code);\n  }\n  /**\n   * After `<!-`, inside a comment, at another `-`.\n   *\n   * ```markdown\n   * > | <!--xxx-->\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function commentOpenInside(code) {\n    if (code === codes.dash) {\n      effects.consume(code); // // Do not form containers.\n      // tokenizer.concrete = true\n\n      return self.interrupt ? ok : continuationDeclarationInside;\n    }\n\n    return nok(code);\n  }\n  /**\n   * After `<![`, inside CDATA, expecting `CDATA[`.\n   *\n   * ```markdown\n   * > | <![CDATA[>&<]]>\n   *        ^^^^^^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function cdataOpenInside(code) {\n    const value = constants.cdataOpeningString;\n\n    if (code === value.charCodeAt(index++)) {\n      effects.consume(code);\n\n      if (index === value.length) {\n        // // Do not form containers.\n        // tokenizer.concrete = true\n        return self.interrupt ? ok : continuation;\n      }\n\n      return cdataOpenInside;\n    }\n\n    return nok(code);\n  }\n  /**\n   * After `</`, in closing tag, at tag name.\n   *\n   * ```markdown\n   * > | </x>\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function tagCloseStart(code) {\n    if (asciiAlpha(code)) {\n      effects.consume(code); // @ts-expect-error: not null.\n\n      buffer = String.fromCharCode(code);\n      return tagName;\n    }\n\n    return nok(code);\n  }\n  /**\n   * In tag name.\n   *\n   * ```markdown\n   * > | <ab>\n   *      ^^\n   * > | </ab>\n   *       ^^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function tagName(code) {\n    if (code === codes.eof || code === codes.slash || code === codes.greaterThan || markdownLineEndingOrSpace(code)) {\n      const slash = code === codes.slash;\n      const name = buffer.toLowerCase();\n\n      if (!slash && !closingTag && htmlRawNames.includes(name)) {\n        marker = constants.htmlRaw; // // Do not form containers.\n        // tokenizer.concrete = true\n\n        return self.interrupt ? ok(code) : continuation(code);\n      }\n\n      if (htmlBlockNames.includes(buffer.toLowerCase())) {\n        marker = constants.htmlBasic;\n\n        if (slash) {\n          effects.consume(code);\n          return basicSelfClosing;\n        } // // Do not form containers.\n        // tokenizer.concrete = true\n\n\n        return self.interrupt ? ok(code) : continuation(code);\n      }\n\n      marker = constants.htmlComplete; // Do not support complete HTML when interrupting.\n\n      return self.interrupt && !self.parser.lazy[self.now().line] ? nok(code) : closingTag ? completeClosingTagAfter(code) : completeAttributeNameBefore(code);\n    } // ASCII alphanumerical and `-`.\n\n\n    if (code === codes.dash || asciiAlphanumeric(code)) {\n      effects.consume(code);\n      buffer += String.fromCharCode(code);\n      return tagName;\n    }\n\n    return nok(code);\n  }\n  /**\n   * After closing slash of a basic tag name.\n   *\n   * ```markdown\n   * > | <div/>\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function basicSelfClosing(code) {\n    if (code === codes.greaterThan) {\n      effects.consume(code); // // Do not form containers.\n      // tokenizer.concrete = true\n\n      return self.interrupt ? ok : continuation;\n    }\n\n    return nok(code);\n  }\n  /**\n   * After closing slash of a complete tag name.\n   *\n   * ```markdown\n   * > | <x/>\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function completeClosingTagAfter(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return completeClosingTagAfter;\n    }\n\n    return completeEnd(code);\n  }\n  /**\n   * At an attribute name.\n   *\n   * At first, this state is used after a complete tag name, after whitespace,\n   * where it expects optional attributes or the end of the tag.\n   * It is also reused after attributes, when expecting more optional\n   * attributes.\n   *\n   * ```markdown\n   * > | <a />\n   *        ^\n   * > | <a :b>\n   *        ^\n   * > | <a _b>\n   *        ^\n   * > | <a b>\n   *        ^\n   * > | <a >\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function completeAttributeNameBefore(code) {\n    if (code === codes.slash) {\n      effects.consume(code);\n      return completeEnd;\n    } // ASCII alphanumerical and `:` and `_`.\n\n\n    if (code === codes.colon || code === codes.underscore || asciiAlpha(code)) {\n      effects.consume(code);\n      return completeAttributeName;\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return completeAttributeNameBefore;\n    }\n\n    return completeEnd(code);\n  }\n  /**\n   * In attribute name.\n   *\n   * ```markdown\n   * > | <a :b>\n   *         ^\n   * > | <a _b>\n   *         ^\n   * > | <a b>\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function completeAttributeName(code) {\n    // ASCII alphanumerical and `-`, `.`, `:`, and `_`.\n    if (code === codes.dash || code === codes.dot || code === codes.colon || code === codes.underscore || asciiAlphanumeric(code)) {\n      effects.consume(code);\n      return completeAttributeName;\n    }\n\n    return completeAttributeNameAfter(code);\n  }\n  /**\n   * After attribute name, at an optional initializer, the end of the tag, or\n   * whitespace.\n   *\n   * ```markdown\n   * > | <a b>\n   *         ^\n   * > | <a b=c>\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function completeAttributeNameAfter(code) {\n    if (code === codes.equalsTo) {\n      effects.consume(code);\n      return completeAttributeValueBefore;\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return completeAttributeNameAfter;\n    }\n\n    return completeAttributeNameBefore(code);\n  }\n  /**\n   * Before unquoted, double quoted, or single quoted attribute value, allowing\n   * whitespace.\n   *\n   * ```markdown\n   * > | <a b=c>\n   *          ^\n   * > | <a b=\"c\">\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function completeAttributeValueBefore(code) {\n    if (code === codes.eof || code === codes.lessThan || code === codes.equalsTo || code === codes.greaterThan || code === codes.graveAccent) {\n      return nok(code);\n    }\n\n    if (code === codes.quotationMark || code === codes.apostrophe) {\n      effects.consume(code);\n      markerB = code;\n      return completeAttributeValueQuoted;\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return completeAttributeValueBefore;\n    }\n\n    return completeAttributeValueUnquoted(code);\n  }\n  /**\n   * In double or single quoted attribute value.\n   *\n   * ```markdown\n   * > | <a b=\"c\">\n   *           ^\n   * > | <a b='c'>\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function completeAttributeValueQuoted(code) {\n    if (code === markerB) {\n      effects.consume(code);\n      markerB = null;\n      return completeAttributeValueQuotedAfter;\n    }\n\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return nok(code);\n    }\n\n    effects.consume(code);\n    return completeAttributeValueQuoted;\n  }\n  /**\n   * In unquoted attribute value.\n   *\n   * ```markdown\n   * > | <a b=c>\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function completeAttributeValueUnquoted(code) {\n    if (code === codes.eof || code === codes.quotationMark || code === codes.apostrophe || code === codes.slash || code === codes.lessThan || code === codes.equalsTo || code === codes.greaterThan || code === codes.graveAccent || markdownLineEndingOrSpace(code)) {\n      return completeAttributeNameAfter(code);\n    }\n\n    effects.consume(code);\n    return completeAttributeValueUnquoted;\n  }\n  /**\n   * After double or single quoted attribute value, before whitespace or the\n   * end of the tag.\n   *\n   * ```markdown\n   * > | <a b=\"c\">\n   *            ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function completeAttributeValueQuotedAfter(code) {\n    if (code === codes.slash || code === codes.greaterThan || markdownSpace(code)) {\n      return completeAttributeNameBefore(code);\n    }\n\n    return nok(code);\n  }\n  /**\n   * In certain circumstances of a complete tag where only an `>` is allowed.\n   *\n   * ```markdown\n   * > | <a b=\"c\">\n   *             ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function completeEnd(code) {\n    if (code === codes.greaterThan) {\n      effects.consume(code);\n      return completeAfter;\n    }\n\n    return nok(code);\n  }\n  /**\n   * After `>` in a complete tag.\n   *\n   * ```markdown\n   * > | <x>\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function completeAfter(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      // // Do not form containers.\n      // tokenizer.concrete = true\n      return continuation(code);\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return completeAfter;\n    }\n\n    return nok(code);\n  }\n  /**\n   * In continuation of any HTML kind.\n   *\n   * ```markdown\n   * > | <!--xxx-->\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function continuation(code) {\n    if (code === codes.dash && marker === constants.htmlComment) {\n      effects.consume(code);\n      return continuationCommentInside;\n    }\n\n    if (code === codes.lessThan && marker === constants.htmlRaw) {\n      effects.consume(code);\n      return continuationRawTagOpen;\n    }\n\n    if (code === codes.greaterThan && marker === constants.htmlDeclaration) {\n      effects.consume(code);\n      return continuationClose;\n    }\n\n    if (code === codes.questionMark && marker === constants.htmlInstruction) {\n      effects.consume(code);\n      return continuationDeclarationInside;\n    }\n\n    if (code === codes.rightSquareBracket && marker === constants.htmlCdata) {\n      effects.consume(code);\n      return continuationCdataInside;\n    }\n\n    if (markdownLineEnding(code) && (marker === constants.htmlBasic || marker === constants.htmlComplete)) {\n      effects.exit(types.htmlFlowData);\n      return effects.check(blankLineBefore, continuationAfter, continuationStart)(code);\n    }\n\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.htmlFlowData);\n      return continuationStart(code);\n    }\n\n    effects.consume(code);\n    return continuation;\n  }\n  /**\n   * In continuation, at eol.\n   *\n   * ```markdown\n   * > | <x>\n   *        ^\n   *   | asd\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function continuationStart(code) {\n    return effects.check(nonLazyContinuationStart, continuationStartNonLazy, continuationAfter)(code);\n  }\n  /**\n   * In continuation, at eol, before non-lazy content.\n   *\n   * ```markdown\n   * > | <x>\n   *        ^\n   *   | asd\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function continuationStartNonLazy(code) {\n    assert(markdownLineEnding(code));\n    effects.enter(types.lineEnding);\n    effects.consume(code);\n    effects.exit(types.lineEnding);\n    return continuationBefore;\n  }\n  /**\n   * In continuation, before non-lazy content.\n   *\n   * ```markdown\n   *   | <x>\n   * > | asd\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function continuationBefore(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return continuationStart(code);\n    }\n\n    effects.enter(types.htmlFlowData);\n    return continuation(code);\n  }\n  /**\n   * In comment continuation, after one `-`, expecting another.\n   *\n   * ```markdown\n   * > | <!--xxx-->\n   *             ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function continuationCommentInside(code) {\n    if (code === codes.dash) {\n      effects.consume(code);\n      return continuationDeclarationInside;\n    }\n\n    return continuation(code);\n  }\n  /**\n   * In raw continuation, after `<`, at `/`.\n   *\n   * ```markdown\n   * > | <script>console.log(1)</script>\n   *                            ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function continuationRawTagOpen(code) {\n    if (code === codes.slash) {\n      effects.consume(code);\n      buffer = '';\n      return continuationRawEndTag;\n    }\n\n    return continuation(code);\n  }\n  /**\n   * In raw continuation, after `</`, in a raw tag name.\n   *\n   * ```markdown\n   * > | <script>console.log(1)</script>\n   *                             ^^^^^^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function continuationRawEndTag(code) {\n    if (code === codes.greaterThan) {\n      const name = buffer.toLowerCase();\n\n      if (htmlRawNames.includes(name)) {\n        effects.consume(code);\n        return continuationClose;\n      }\n\n      return continuation(code);\n    }\n\n    if (asciiAlpha(code) && buffer.length < constants.htmlRawSizeMax) {\n      effects.consume(code); // @ts-expect-error: not null.\n\n      buffer += String.fromCharCode(code);\n      return continuationRawEndTag;\n    }\n\n    return continuation(code);\n  }\n  /**\n   * In cdata continuation, after `]`, expecting `]>`.\n   *\n   * ```markdown\n   * > | <![CDATA[>&<]]>\n   *                  ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function continuationCdataInside(code) {\n    if (code === codes.rightSquareBracket) {\n      effects.consume(code);\n      return continuationDeclarationInside;\n    }\n\n    return continuation(code);\n  }\n  /**\n   * In declaration or instruction continuation, at `>`.\n   *\n   * ```markdown\n   * > | <!-->\n   *         ^\n   * > | <?>\n   *       ^\n   * > | <!q>\n   *        ^\n   * > | <!--ab-->\n   *             ^\n   * > | <![CDATA[>&<]]>\n   *                   ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function continuationDeclarationInside(code) {\n    if (code === codes.greaterThan) {\n      effects.consume(code);\n      return continuationClose;\n    } // More dashes.\n\n\n    if (code === codes.dash && marker === constants.htmlComment) {\n      effects.consume(code);\n      return continuationDeclarationInside;\n    }\n\n    return continuation(code);\n  }\n  /**\n   * In closed continuation: everything we get until the eol/eof is part of it.\n   *\n   * ```markdown\n   * > | <!doctype>\n   *               ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function continuationClose(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.htmlFlowData);\n      return continuationAfter(code);\n    }\n\n    effects.consume(code);\n    return continuationClose;\n  }\n  /**\n   * Done.\n   *\n   * ```markdown\n   * > | <!doctype>\n   *               ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function continuationAfter(code) {\n    effects.exit(types.htmlFlow); // // Feel free to interrupt.\n    // tokenizer.interrupt = false\n    // // No longer concrete.\n    // tokenizer.concrete = false\n\n    return ok(code);\n  }\n}\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\n\n\nfunction tokenizeNonLazyContinuationStart(effects, ok, nok) {\n  const self = this;\n  return start;\n  /**\n   * At eol, before continuation.\n   *\n   * ```markdown\n   * > | * ```js\n   *            ^\n   *   | b\n   * ```\n   *\n   * @type {State}\n   */\n\n  function start(code) {\n    if (markdownLineEnding(code)) {\n      effects.enter(types.lineEnding);\n      effects.consume(code);\n      effects.exit(types.lineEnding);\n      return after;\n    }\n\n    return nok(code);\n  }\n  /**\n   * A continuation.\n   *\n   * ```markdown\n   *   | * ```js\n   * > | b\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function after(code) {\n    return self.parser.lazy[self.now().line] ? nok(code) : ok(code);\n  }\n}\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\n\n\nfunction tokenizeBlankLineBefore(effects, ok, nok) {\n  return start;\n  /**\n   * Before eol, expecting blank line.\n   *\n   * ```markdown\n   * > | <div>\n   *          ^\n   *   |\n   * ```\n   *\n   * @type {State}\n   */\n\n  function start(code) {\n    assert(markdownLineEnding(code), 'expected a line ending');\n    effects.enter(types.lineEnding);\n    effects.consume(code);\n    effects.exit(types.lineEnding);\n    return effects.attempt(blankLine, ok, nok);\n  }\n}","map":{"version":3,"sources":["D:/com lab/react/keerthana/auth2/AuthInMern/client/node_modules/micromark-core-commonmark/dev/lib/html-flow.js"],"names":["asciiAlpha","asciiAlphanumeric","markdownLineEnding","markdownLineEndingOrSpace","markdownSpace","htmlBlockNames","htmlRawNames","codes","constants","types","ok","assert","blankLine","htmlFlow","name","tokenize","tokenizeHtmlFlow","resolveTo","resolveToHtmlFlow","concrete","blankLineBefore","tokenizeBlankLineBefore","partial","nonLazyContinuationStart","tokenizeNonLazyContinuationStart","events","index","length","type","linePrefix","start","splice","effects","nok","self","marker","closingTag","buffer","markerB","code","before","lessThan","enter","htmlFlowData","consume","open","exclamationMark","declarationOpen","slash","tagCloseStart","questionMark","htmlInstruction","interrupt","continuationDeclarationInside","String","fromCharCode","tagName","dash","htmlComment","commentOpenInside","leftSquareBracket","htmlCdata","cdataOpenInside","htmlDeclaration","value","cdataOpeningString","charCodeAt","continuation","eof","greaterThan","toLowerCase","includes","htmlRaw","htmlBasic","basicSelfClosing","htmlComplete","parser","lazy","now","line","completeClosingTagAfter","completeAttributeNameBefore","completeEnd","colon","underscore","completeAttributeName","dot","completeAttributeNameAfter","equalsTo","completeAttributeValueBefore","graveAccent","quotationMark","apostrophe","completeAttributeValueQuoted","completeAttributeValueUnquoted","completeAttributeValueQuotedAfter","completeAfter","continuationCommentInside","continuationRawTagOpen","continuationClose","rightSquareBracket","continuationCdataInside","exit","check","continuationAfter","continuationStart","continuationStartNonLazy","lineEnding","continuationBefore","continuationRawEndTag","htmlRawSizeMax","after","attempt"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {\n  asciiAlpha,\n  asciiAlphanumeric,\n  markdownLineEnding,\n  markdownLineEndingOrSpace,\n  markdownSpace\n} from 'micromark-util-character'\nimport {htmlBlockNames, htmlRawNames} from 'micromark-util-html-tag-name'\nimport {codes} from 'micromark-util-symbol/codes.js'\nimport {constants} from 'micromark-util-symbol/constants.js'\nimport {types} from 'micromark-util-symbol/types.js'\nimport {ok as assert} from 'uvu/assert'\nimport {blankLine} from './blank-line.js'\n\n/** @type {Construct} */\nexport const htmlFlow = {\n  name: 'htmlFlow',\n  tokenize: tokenizeHtmlFlow,\n  resolveTo: resolveToHtmlFlow,\n  concrete: true\n}\n\n/** @type {Construct} */\nconst blankLineBefore = {tokenize: tokenizeBlankLineBefore, partial: true}\nconst nonLazyContinuationStart = {\n  tokenize: tokenizeNonLazyContinuationStart,\n  partial: true\n}\n\n/** @type {Resolver} */\nfunction resolveToHtmlFlow(events) {\n  let index = events.length\n\n  while (index--) {\n    if (\n      events[index][0] === 'enter' &&\n      events[index][1].type === types.htmlFlow\n    ) {\n      break\n    }\n  }\n\n  if (index > 1 && events[index - 2][1].type === types.linePrefix) {\n    // Add the prefix start to the HTML token.\n    events[index][1].start = events[index - 2][1].start\n    // Add the prefix start to the HTML line token.\n    events[index + 1][1].start = events[index - 2][1].start\n    // Remove the line prefix.\n    events.splice(index - 2, 2)\n  }\n\n  return events\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeHtmlFlow(effects, ok, nok) {\n  const self = this\n  /** @type {number} */\n  let marker\n  /** @type {boolean} */\n  let closingTag\n  /** @type {string} */\n  let buffer\n  /** @type {number} */\n  let index\n  /** @type {Code} */\n  let markerB\n\n  return start\n\n  /**\n   * Start of HTML (flow).\n   *\n   * ```markdown\n   * > | <x />\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    // To do: parse indent like `markdown-rs`.\n    return before(code)\n  }\n\n  /**\n   * At `<`, after optional whitespace.\n   *\n   * ```markdown\n   * > | <x />\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function before(code) {\n    assert(code === codes.lessThan, 'expected `<`')\n    effects.enter(types.htmlFlow)\n    effects.enter(types.htmlFlowData)\n    effects.consume(code)\n    return open\n  }\n\n  /**\n   * After `<`, at tag name or other stuff.\n   *\n   * ```markdown\n   * > | <x />\n   *      ^\n   * > | <!doctype>\n   *      ^\n   * > | <!--xxx-->\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function open(code) {\n    if (code === codes.exclamationMark) {\n      effects.consume(code)\n      return declarationOpen\n    }\n\n    if (code === codes.slash) {\n      effects.consume(code)\n      closingTag = true\n      return tagCloseStart\n    }\n\n    if (code === codes.questionMark) {\n      effects.consume(code)\n      marker = constants.htmlInstruction\n      // To do:\n      // tokenizer.concrete = true\n      // To do: use `markdown-rs` style interrupt.\n      // While we’re in an instruction instead of a declaration, we’re on a `?`\n      // right now, so we do need to search for `>`, similar to declarations.\n      return self.interrupt ? ok : continuationDeclarationInside\n    }\n\n    // ASCII alphabetical.\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      // @ts-expect-error: not null.\n      buffer = String.fromCharCode(code)\n      return tagName\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * After `<!`, at declaration, comment, or CDATA.\n   *\n   * ```markdown\n   * > | <!doctype>\n   *       ^\n   * > | <!--xxx-->\n   *       ^\n   * > | <![CDATA[>&<]]>\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function declarationOpen(code) {\n    if (code === codes.dash) {\n      effects.consume(code)\n      marker = constants.htmlComment\n      return commentOpenInside\n    }\n\n    if (code === codes.leftSquareBracket) {\n      effects.consume(code)\n      marker = constants.htmlCdata\n      index = 0\n      return cdataOpenInside\n    }\n\n    // ASCII alphabetical.\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      marker = constants.htmlDeclaration\n      // // Do not form containers.\n      // tokenizer.concrete = true\n      return self.interrupt ? ok : continuationDeclarationInside\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * After `<!-`, inside a comment, at another `-`.\n   *\n   * ```markdown\n   * > | <!--xxx-->\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function commentOpenInside(code) {\n    if (code === codes.dash) {\n      effects.consume(code)\n      // // Do not form containers.\n      // tokenizer.concrete = true\n      return self.interrupt ? ok : continuationDeclarationInside\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * After `<![`, inside CDATA, expecting `CDATA[`.\n   *\n   * ```markdown\n   * > | <![CDATA[>&<]]>\n   *        ^^^^^^\n   * ```\n   *\n   * @type {State}\n   */\n  function cdataOpenInside(code) {\n    const value = constants.cdataOpeningString\n\n    if (code === value.charCodeAt(index++)) {\n      effects.consume(code)\n\n      if (index === value.length) {\n        // // Do not form containers.\n        // tokenizer.concrete = true\n        return self.interrupt ? ok : continuation\n      }\n\n      return cdataOpenInside\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * After `</`, in closing tag, at tag name.\n   *\n   * ```markdown\n   * > | </x>\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagCloseStart(code) {\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      // @ts-expect-error: not null.\n      buffer = String.fromCharCode(code)\n      return tagName\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * In tag name.\n   *\n   * ```markdown\n   * > | <ab>\n   *      ^^\n   * > | </ab>\n   *       ^^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagName(code) {\n    if (\n      code === codes.eof ||\n      code === codes.slash ||\n      code === codes.greaterThan ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      const slash = code === codes.slash\n      const name = buffer.toLowerCase()\n\n      if (!slash && !closingTag && htmlRawNames.includes(name)) {\n        marker = constants.htmlRaw\n        // // Do not form containers.\n        // tokenizer.concrete = true\n        return self.interrupt ? ok(code) : continuation(code)\n      }\n\n      if (htmlBlockNames.includes(buffer.toLowerCase())) {\n        marker = constants.htmlBasic\n\n        if (slash) {\n          effects.consume(code)\n          return basicSelfClosing\n        }\n\n        // // Do not form containers.\n        // tokenizer.concrete = true\n        return self.interrupt ? ok(code) : continuation(code)\n      }\n\n      marker = constants.htmlComplete\n      // Do not support complete HTML when interrupting.\n      return self.interrupt && !self.parser.lazy[self.now().line]\n        ? nok(code)\n        : closingTag\n        ? completeClosingTagAfter(code)\n        : completeAttributeNameBefore(code)\n    }\n\n    // ASCII alphanumerical and `-`.\n    if (code === codes.dash || asciiAlphanumeric(code)) {\n      effects.consume(code)\n      buffer += String.fromCharCode(code)\n      return tagName\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * After closing slash of a basic tag name.\n   *\n   * ```markdown\n   * > | <div/>\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function basicSelfClosing(code) {\n    if (code === codes.greaterThan) {\n      effects.consume(code)\n      // // Do not form containers.\n      // tokenizer.concrete = true\n      return self.interrupt ? ok : continuation\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * After closing slash of a complete tag name.\n   *\n   * ```markdown\n   * > | <x/>\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeClosingTagAfter(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeClosingTagAfter\n    }\n\n    return completeEnd(code)\n  }\n\n  /**\n   * At an attribute name.\n   *\n   * At first, this state is used after a complete tag name, after whitespace,\n   * where it expects optional attributes or the end of the tag.\n   * It is also reused after attributes, when expecting more optional\n   * attributes.\n   *\n   * ```markdown\n   * > | <a />\n   *        ^\n   * > | <a :b>\n   *        ^\n   * > | <a _b>\n   *        ^\n   * > | <a b>\n   *        ^\n   * > | <a >\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeAttributeNameBefore(code) {\n    if (code === codes.slash) {\n      effects.consume(code)\n      return completeEnd\n    }\n\n    // ASCII alphanumerical and `:` and `_`.\n    if (code === codes.colon || code === codes.underscore || asciiAlpha(code)) {\n      effects.consume(code)\n      return completeAttributeName\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeAttributeNameBefore\n    }\n\n    return completeEnd(code)\n  }\n\n  /**\n   * In attribute name.\n   *\n   * ```markdown\n   * > | <a :b>\n   *         ^\n   * > | <a _b>\n   *         ^\n   * > | <a b>\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeAttributeName(code) {\n    // ASCII alphanumerical and `-`, `.`, `:`, and `_`.\n    if (\n      code === codes.dash ||\n      code === codes.dot ||\n      code === codes.colon ||\n      code === codes.underscore ||\n      asciiAlphanumeric(code)\n    ) {\n      effects.consume(code)\n      return completeAttributeName\n    }\n\n    return completeAttributeNameAfter(code)\n  }\n\n  /**\n   * After attribute name, at an optional initializer, the end of the tag, or\n   * whitespace.\n   *\n   * ```markdown\n   * > | <a b>\n   *         ^\n   * > | <a b=c>\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeAttributeNameAfter(code) {\n    if (code === codes.equalsTo) {\n      effects.consume(code)\n      return completeAttributeValueBefore\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeAttributeNameAfter\n    }\n\n    return completeAttributeNameBefore(code)\n  }\n\n  /**\n   * Before unquoted, double quoted, or single quoted attribute value, allowing\n   * whitespace.\n   *\n   * ```markdown\n   * > | <a b=c>\n   *          ^\n   * > | <a b=\"c\">\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeAttributeValueBefore(code) {\n    if (\n      code === codes.eof ||\n      code === codes.lessThan ||\n      code === codes.equalsTo ||\n      code === codes.greaterThan ||\n      code === codes.graveAccent\n    ) {\n      return nok(code)\n    }\n\n    if (code === codes.quotationMark || code === codes.apostrophe) {\n      effects.consume(code)\n      markerB = code\n      return completeAttributeValueQuoted\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeAttributeValueBefore\n    }\n\n    return completeAttributeValueUnquoted(code)\n  }\n\n  /**\n   * In double or single quoted attribute value.\n   *\n   * ```markdown\n   * > | <a b=\"c\">\n   *           ^\n   * > | <a b='c'>\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeAttributeValueQuoted(code) {\n    if (code === markerB) {\n      effects.consume(code)\n      markerB = null\n      return completeAttributeValueQuotedAfter\n    }\n\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return nok(code)\n    }\n\n    effects.consume(code)\n    return completeAttributeValueQuoted\n  }\n\n  /**\n   * In unquoted attribute value.\n   *\n   * ```markdown\n   * > | <a b=c>\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeAttributeValueUnquoted(code) {\n    if (\n      code === codes.eof ||\n      code === codes.quotationMark ||\n      code === codes.apostrophe ||\n      code === codes.slash ||\n      code === codes.lessThan ||\n      code === codes.equalsTo ||\n      code === codes.greaterThan ||\n      code === codes.graveAccent ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      return completeAttributeNameAfter(code)\n    }\n\n    effects.consume(code)\n    return completeAttributeValueUnquoted\n  }\n\n  /**\n   * After double or single quoted attribute value, before whitespace or the\n   * end of the tag.\n   *\n   * ```markdown\n   * > | <a b=\"c\">\n   *            ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeAttributeValueQuotedAfter(code) {\n    if (\n      code === codes.slash ||\n      code === codes.greaterThan ||\n      markdownSpace(code)\n    ) {\n      return completeAttributeNameBefore(code)\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * In certain circumstances of a complete tag where only an `>` is allowed.\n   *\n   * ```markdown\n   * > | <a b=\"c\">\n   *             ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeEnd(code) {\n    if (code === codes.greaterThan) {\n      effects.consume(code)\n      return completeAfter\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * After `>` in a complete tag.\n   *\n   * ```markdown\n   * > | <x>\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeAfter(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      // // Do not form containers.\n      // tokenizer.concrete = true\n      return continuation(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeAfter\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * In continuation of any HTML kind.\n   *\n   * ```markdown\n   * > | <!--xxx-->\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function continuation(code) {\n    if (code === codes.dash && marker === constants.htmlComment) {\n      effects.consume(code)\n      return continuationCommentInside\n    }\n\n    if (code === codes.lessThan && marker === constants.htmlRaw) {\n      effects.consume(code)\n      return continuationRawTagOpen\n    }\n\n    if (code === codes.greaterThan && marker === constants.htmlDeclaration) {\n      effects.consume(code)\n      return continuationClose\n    }\n\n    if (code === codes.questionMark && marker === constants.htmlInstruction) {\n      effects.consume(code)\n      return continuationDeclarationInside\n    }\n\n    if (code === codes.rightSquareBracket && marker === constants.htmlCdata) {\n      effects.consume(code)\n      return continuationCdataInside\n    }\n\n    if (\n      markdownLineEnding(code) &&\n      (marker === constants.htmlBasic || marker === constants.htmlComplete)\n    ) {\n      effects.exit(types.htmlFlowData)\n      return effects.check(\n        blankLineBefore,\n        continuationAfter,\n        continuationStart\n      )(code)\n    }\n\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.htmlFlowData)\n      return continuationStart(code)\n    }\n\n    effects.consume(code)\n    return continuation\n  }\n\n  /**\n   * In continuation, at eol.\n   *\n   * ```markdown\n   * > | <x>\n   *        ^\n   *   | asd\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationStart(code) {\n    return effects.check(\n      nonLazyContinuationStart,\n      continuationStartNonLazy,\n      continuationAfter\n    )(code)\n  }\n\n  /**\n   * In continuation, at eol, before non-lazy content.\n   *\n   * ```markdown\n   * > | <x>\n   *        ^\n   *   | asd\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationStartNonLazy(code) {\n    assert(markdownLineEnding(code))\n    effects.enter(types.lineEnding)\n    effects.consume(code)\n    effects.exit(types.lineEnding)\n    return continuationBefore\n  }\n\n  /**\n   * In continuation, before non-lazy content.\n   *\n   * ```markdown\n   *   | <x>\n   * > | asd\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationBefore(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return continuationStart(code)\n    }\n\n    effects.enter(types.htmlFlowData)\n    return continuation(code)\n  }\n\n  /**\n   * In comment continuation, after one `-`, expecting another.\n   *\n   * ```markdown\n   * > | <!--xxx-->\n   *             ^\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationCommentInside(code) {\n    if (code === codes.dash) {\n      effects.consume(code)\n      return continuationDeclarationInside\n    }\n\n    return continuation(code)\n  }\n\n  /**\n   * In raw continuation, after `<`, at `/`.\n   *\n   * ```markdown\n   * > | <script>console.log(1)</script>\n   *                            ^\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationRawTagOpen(code) {\n    if (code === codes.slash) {\n      effects.consume(code)\n      buffer = ''\n      return continuationRawEndTag\n    }\n\n    return continuation(code)\n  }\n\n  /**\n   * In raw continuation, after `</`, in a raw tag name.\n   *\n   * ```markdown\n   * > | <script>console.log(1)</script>\n   *                             ^^^^^^\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationRawEndTag(code) {\n    if (code === codes.greaterThan) {\n      const name = buffer.toLowerCase()\n\n      if (htmlRawNames.includes(name)) {\n        effects.consume(code)\n        return continuationClose\n      }\n\n      return continuation(code)\n    }\n\n    if (asciiAlpha(code) && buffer.length < constants.htmlRawSizeMax) {\n      effects.consume(code)\n      // @ts-expect-error: not null.\n      buffer += String.fromCharCode(code)\n      return continuationRawEndTag\n    }\n\n    return continuation(code)\n  }\n\n  /**\n   * In cdata continuation, after `]`, expecting `]>`.\n   *\n   * ```markdown\n   * > | <![CDATA[>&<]]>\n   *                  ^\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationCdataInside(code) {\n    if (code === codes.rightSquareBracket) {\n      effects.consume(code)\n      return continuationDeclarationInside\n    }\n\n    return continuation(code)\n  }\n\n  /**\n   * In declaration or instruction continuation, at `>`.\n   *\n   * ```markdown\n   * > | <!-->\n   *         ^\n   * > | <?>\n   *       ^\n   * > | <!q>\n   *        ^\n   * > | <!--ab-->\n   *             ^\n   * > | <![CDATA[>&<]]>\n   *                   ^\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationDeclarationInside(code) {\n    if (code === codes.greaterThan) {\n      effects.consume(code)\n      return continuationClose\n    }\n\n    // More dashes.\n    if (code === codes.dash && marker === constants.htmlComment) {\n      effects.consume(code)\n      return continuationDeclarationInside\n    }\n\n    return continuation(code)\n  }\n\n  /**\n   * In closed continuation: everything we get until the eol/eof is part of it.\n   *\n   * ```markdown\n   * > | <!doctype>\n   *               ^\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationClose(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.htmlFlowData)\n      return continuationAfter(code)\n    }\n\n    effects.consume(code)\n    return continuationClose\n  }\n\n  /**\n   * Done.\n   *\n   * ```markdown\n   * > | <!doctype>\n   *               ^\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationAfter(code) {\n    effects.exit(types.htmlFlow)\n    // // Feel free to interrupt.\n    // tokenizer.interrupt = false\n    // // No longer concrete.\n    // tokenizer.concrete = false\n    return ok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeNonLazyContinuationStart(effects, ok, nok) {\n  const self = this\n\n  return start\n\n  /**\n   * At eol, before continuation.\n   *\n   * ```markdown\n   * > | * ```js\n   *            ^\n   *   | b\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    if (markdownLineEnding(code)) {\n      effects.enter(types.lineEnding)\n      effects.consume(code)\n      effects.exit(types.lineEnding)\n      return after\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * A continuation.\n   *\n   * ```markdown\n   *   | * ```js\n   * > | b\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    return self.parser.lazy[self.now().line] ? nok(code) : ok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeBlankLineBefore(effects, ok, nok) {\n  return start\n\n  /**\n   * Before eol, expecting blank line.\n   *\n   * ```markdown\n   * > | <div>\n   *          ^\n   *   |\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    assert(markdownLineEnding(code), 'expected a line ending')\n    effects.enter(types.lineEnding)\n    effects.consume(code)\n    effects.exit(types.lineEnding)\n    return effects.attempt(blankLine, ok, nok)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEnding, markdownSpace } from 'micromark-util-character';\nimport { codes } from 'micromark-util-symbol/codes.js';\nimport { constants } from 'micromark-util-symbol/constants.js';\nimport { types } from 'micromark-util-symbol/types.js';\nimport { ok as assert } from 'uvu/assert';\n/** @type {Construct} */\n\nconst nonLazyContinuation = {\n  tokenize: tokenizeNonLazyContinuation,\n  partial: true\n};\n/** @type {Construct} */\n\nexport const codeFenced = {\n  name: 'codeFenced',\n  tokenize: tokenizeCodeFenced,\n  concrete: true\n};\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\n\nfunction tokenizeCodeFenced(effects, ok, nok) {\n  const self = this;\n  /** @type {Construct} */\n\n  const closeStart = {\n    tokenize: tokenizeCloseStart,\n    partial: true\n  };\n  let initialPrefix = 0;\n  let sizeOpen = 0;\n  /** @type {NonNullable<Code>} */\n\n  let marker;\n  return start;\n  /**\n   * Start of code.\n   *\n   * ```markdown\n   * > | ~~~js\n   *     ^\n   *   | alert(1)\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n\n  function start(code) {\n    // To do: parse whitespace like `markdown-rs`.\n    return beforeSequenceOpen(code);\n  }\n  /**\n   * In opening fence, after prefix, at sequence.\n   *\n   * ```markdown\n   * > | ~~~js\n   *     ^\n   *   | alert(1)\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function beforeSequenceOpen(code) {\n    assert(code === codes.graveAccent || code === codes.tilde, 'expected `` ` `` or `~`');\n    const tail = self.events[self.events.length - 1];\n    initialPrefix = tail && tail[1].type === types.linePrefix ? tail[2].sliceSerialize(tail[1], true).length : 0;\n    marker = code;\n    effects.enter(types.codeFenced);\n    effects.enter(types.codeFencedFence);\n    effects.enter(types.codeFencedFenceSequence);\n    return sequenceOpen(code);\n  }\n  /**\n   * In opening fence sequence.\n   *\n   * ```markdown\n   * > | ~~~js\n   *      ^\n   *   | alert(1)\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function sequenceOpen(code) {\n    if (code === marker) {\n      sizeOpen++;\n      effects.consume(code);\n      return sequenceOpen;\n    }\n\n    if (sizeOpen < constants.codeFencedSequenceSizeMin) {\n      return nok(code);\n    }\n\n    effects.exit(types.codeFencedFenceSequence);\n    return markdownSpace(code) ? factorySpace(effects, infoBefore, types.whitespace)(code) : infoBefore(code);\n  }\n  /**\n   * In opening fence, after the sequence (and optional whitespace), before info.\n   *\n   * ```markdown\n   * > | ~~~js\n   *        ^\n   *   | alert(1)\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function infoBefore(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.codeFencedFence);\n      return self.interrupt ? ok(code) : effects.check(nonLazyContinuation, atNonLazyBreak, after)(code);\n    }\n\n    effects.enter(types.codeFencedFenceInfo);\n    effects.enter(types.chunkString, {\n      contentType: constants.contentTypeString\n    });\n    return info(code);\n  }\n  /**\n   * In info.\n   *\n   * ```markdown\n   * > | ~~~js\n   *        ^\n   *   | alert(1)\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function info(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.chunkString);\n      effects.exit(types.codeFencedFenceInfo);\n      return infoBefore(code);\n    }\n\n    if (markdownSpace(code)) {\n      effects.exit(types.chunkString);\n      effects.exit(types.codeFencedFenceInfo);\n      return factorySpace(effects, metaBefore, types.whitespace)(code);\n    }\n\n    if (code === codes.graveAccent && code === marker) {\n      return nok(code);\n    }\n\n    effects.consume(code);\n    return info;\n  }\n  /**\n   * In opening fence, after info and whitespace, before meta.\n   *\n   * ```markdown\n   * > | ~~~js eval\n   *           ^\n   *   | alert(1)\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function metaBefore(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return infoBefore(code);\n    }\n\n    effects.enter(types.codeFencedFenceMeta);\n    effects.enter(types.chunkString, {\n      contentType: constants.contentTypeString\n    });\n    return meta(code);\n  }\n  /**\n   * In meta.\n   *\n   * ```markdown\n   * > | ~~~js eval\n   *           ^\n   *   | alert(1)\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function meta(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.chunkString);\n      effects.exit(types.codeFencedFenceMeta);\n      return infoBefore(code);\n    }\n\n    if (code === codes.graveAccent && code === marker) {\n      return nok(code);\n    }\n\n    effects.consume(code);\n    return meta;\n  }\n  /**\n   * At eol/eof in code, before a non-lazy closing fence or content.\n   *\n   * ```markdown\n   * > | ~~~js\n   *          ^\n   * > | alert(1)\n   *             ^\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function atNonLazyBreak(code) {\n    assert(markdownLineEnding(code), 'expected eol');\n    return effects.attempt(closeStart, after, contentBefore)(code);\n  }\n  /**\n   * Before code content, not a closing fence, at eol.\n   *\n   * ```markdown\n   *   | ~~~js\n   * > | alert(1)\n   *             ^\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function contentBefore(code) {\n    assert(markdownLineEnding(code), 'expected eol');\n    effects.enter(types.lineEnding);\n    effects.consume(code);\n    effects.exit(types.lineEnding);\n    return contentStart;\n  }\n  /**\n   * Before code content, not a closing fence.\n   *\n   * ```markdown\n   *   | ~~~js\n   * > | alert(1)\n   *     ^\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function contentStart(code) {\n    return initialPrefix > 0 && markdownSpace(code) ? factorySpace(effects, beforeContentChunk, types.linePrefix, initialPrefix + 1)(code) : beforeContentChunk(code);\n  }\n  /**\n   * Before code content, after optional prefix.\n   *\n   * ```markdown\n   *   | ~~~js\n   * > | alert(1)\n   *     ^\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function beforeContentChunk(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return effects.check(nonLazyContinuation, atNonLazyBreak, after)(code);\n    }\n\n    effects.enter(types.codeFlowValue);\n    return contentChunk(code);\n  }\n  /**\n   * In code content.\n   *\n   * ```markdown\n   *   | ~~~js\n   * > | alert(1)\n   *     ^^^^^^^^\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function contentChunk(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.codeFlowValue);\n      return beforeContentChunk(code);\n    }\n\n    effects.consume(code);\n    return contentChunk;\n  }\n  /**\n   * After code.\n   *\n   * ```markdown\n   *   | ~~~js\n   *   | alert(1)\n   * > | ~~~\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function after(code) {\n    effects.exit(types.codeFenced);\n    return ok(code);\n  }\n  /**\n   * @this {TokenizeContext}\n   * @type {Tokenizer}\n   */\n\n\n  function tokenizeCloseStart(effects, ok, nok) {\n    let size = 0;\n    return startBefore;\n    /**\n     *\n     *\n     * @type {State}\n     */\n\n    function startBefore(code) {\n      assert(markdownLineEnding(code), 'expected eol');\n      effects.enter(types.lineEnding);\n      effects.consume(code);\n      effects.exit(types.lineEnding);\n      return start;\n    }\n    /**\n     * Before closing fence, at optional whitespace.\n     *\n     * ```markdown\n     *   | ~~~js\n     *   | alert(1)\n     * > | ~~~\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n\n\n    function start(code) {\n      // Always populated by defaults.\n      assert(self.parser.constructs.disable.null, 'expected `disable.null` to be populated'); // To do: `enter` here or in next state?\n\n      effects.enter(types.codeFencedFence);\n      return markdownSpace(code) ? factorySpace(effects, beforeSequenceClose, types.linePrefix, self.parser.constructs.disable.null.includes('codeIndented') ? undefined : constants.tabSize)(code) : beforeSequenceClose(code);\n    }\n    /**\n     * In closing fence, after optional whitespace, at sequence.\n     *\n     * ```markdown\n     *   | ~~~js\n     *   | alert(1)\n     * > | ~~~\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n\n\n    function beforeSequenceClose(code) {\n      if (code === marker) {\n        effects.enter(types.codeFencedFenceSequence);\n        return sequenceClose(code);\n      }\n\n      return nok(code);\n    }\n    /**\n     * In closing fence sequence.\n     *\n     * ```markdown\n     *   | ~~~js\n     *   | alert(1)\n     * > | ~~~\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n\n\n    function sequenceClose(code) {\n      if (code === marker) {\n        size++;\n        effects.consume(code);\n        return sequenceClose;\n      }\n\n      if (size >= sizeOpen) {\n        effects.exit(types.codeFencedFenceSequence);\n        return markdownSpace(code) ? factorySpace(effects, sequenceCloseAfter, types.whitespace)(code) : sequenceCloseAfter(code);\n      }\n\n      return nok(code);\n    }\n    /**\n     * After closing fence sequence, after optional whitespace.\n     *\n     * ```markdown\n     *   | ~~~js\n     *   | alert(1)\n     * > | ~~~\n     *        ^\n     * ```\n     *\n     * @type {State}\n     */\n\n\n    function sequenceCloseAfter(code) {\n      if (code === codes.eof || markdownLineEnding(code)) {\n        effects.exit(types.codeFencedFence);\n        return ok(code);\n      }\n\n      return nok(code);\n    }\n  }\n}\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\n\n\nfunction tokenizeNonLazyContinuation(effects, ok, nok) {\n  const self = this;\n  return start;\n  /**\n   *\n   *\n   * @type {State}\n   */\n\n  function start(code) {\n    if (code === codes.eof) {\n      return nok(code);\n    }\n\n    assert(markdownLineEnding(code), 'expected eol');\n    effects.enter(types.lineEnding);\n    effects.consume(code);\n    effects.exit(types.lineEnding);\n    return lineStart;\n  }\n  /**\n   *\n   *\n   * @type {State}\n   */\n\n\n  function lineStart(code) {\n    return self.parser.lazy[self.now().line] ? nok(code) : ok(code);\n  }\n}","map":{"version":3,"sources":["D:/com lab/react/keerthana/auth2/AuthInMern/client/node_modules/micromark-core-commonmark/dev/lib/code-fenced.js"],"names":["factorySpace","markdownLineEnding","markdownSpace","codes","constants","types","ok","assert","nonLazyContinuation","tokenize","tokenizeNonLazyContinuation","partial","codeFenced","name","tokenizeCodeFenced","concrete","effects","nok","self","closeStart","tokenizeCloseStart","initialPrefix","sizeOpen","marker","start","code","beforeSequenceOpen","graveAccent","tilde","tail","events","length","type","linePrefix","sliceSerialize","enter","codeFencedFence","codeFencedFenceSequence","sequenceOpen","consume","codeFencedSequenceSizeMin","exit","infoBefore","whitespace","eof","interrupt","check","atNonLazyBreak","after","codeFencedFenceInfo","chunkString","contentType","contentTypeString","info","metaBefore","codeFencedFenceMeta","meta","attempt","contentBefore","lineEnding","contentStart","beforeContentChunk","codeFlowValue","contentChunk","size","startBefore","parser","constructs","disable","null","beforeSequenceClose","includes","undefined","tabSize","sequenceClose","sequenceCloseAfter","lineStart","lazy","now","line"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding, markdownSpace} from 'micromark-util-character'\nimport {codes} from 'micromark-util-symbol/codes.js'\nimport {constants} from 'micromark-util-symbol/constants.js'\nimport {types} from 'micromark-util-symbol/types.js'\nimport {ok as assert} from 'uvu/assert'\n\n/** @type {Construct} */\nconst nonLazyContinuation = {\n  tokenize: tokenizeNonLazyContinuation,\n  partial: true\n}\n\n/** @type {Construct} */\nexport const codeFenced = {\n  name: 'codeFenced',\n  tokenize: tokenizeCodeFenced,\n  concrete: true\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeCodeFenced(effects, ok, nok) {\n  const self = this\n  /** @type {Construct} */\n  const closeStart = {tokenize: tokenizeCloseStart, partial: true}\n  let initialPrefix = 0\n  let sizeOpen = 0\n  /** @type {NonNullable<Code>} */\n  let marker\n\n  return start\n\n  /**\n   * Start of code.\n   *\n   * ```markdown\n   * > | ~~~js\n   *     ^\n   *   | alert(1)\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    // To do: parse whitespace like `markdown-rs`.\n    return beforeSequenceOpen(code)\n  }\n\n  /**\n   * In opening fence, after prefix, at sequence.\n   *\n   * ```markdown\n   * > | ~~~js\n   *     ^\n   *   | alert(1)\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function beforeSequenceOpen(code) {\n    assert(\n      code === codes.graveAccent || code === codes.tilde,\n      'expected `` ` `` or `~`'\n    )\n\n    const tail = self.events[self.events.length - 1]\n    initialPrefix =\n      tail && tail[1].type === types.linePrefix\n        ? tail[2].sliceSerialize(tail[1], true).length\n        : 0\n\n    marker = code\n    effects.enter(types.codeFenced)\n    effects.enter(types.codeFencedFence)\n    effects.enter(types.codeFencedFenceSequence)\n    return sequenceOpen(code)\n  }\n\n  /**\n   * In opening fence sequence.\n   *\n   * ```markdown\n   * > | ~~~js\n   *      ^\n   *   | alert(1)\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function sequenceOpen(code) {\n    if (code === marker) {\n      sizeOpen++\n      effects.consume(code)\n      return sequenceOpen\n    }\n\n    if (sizeOpen < constants.codeFencedSequenceSizeMin) {\n      return nok(code)\n    }\n\n    effects.exit(types.codeFencedFenceSequence)\n    return markdownSpace(code)\n      ? factorySpace(effects, infoBefore, types.whitespace)(code)\n      : infoBefore(code)\n  }\n\n  /**\n   * In opening fence, after the sequence (and optional whitespace), before info.\n   *\n   * ```markdown\n   * > | ~~~js\n   *        ^\n   *   | alert(1)\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function infoBefore(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.codeFencedFence)\n      return self.interrupt\n        ? ok(code)\n        : effects.check(nonLazyContinuation, atNonLazyBreak, after)(code)\n    }\n\n    effects.enter(types.codeFencedFenceInfo)\n    effects.enter(types.chunkString, {contentType: constants.contentTypeString})\n    return info(code)\n  }\n\n  /**\n   * In info.\n   *\n   * ```markdown\n   * > | ~~~js\n   *        ^\n   *   | alert(1)\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function info(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.chunkString)\n      effects.exit(types.codeFencedFenceInfo)\n      return infoBefore(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.exit(types.chunkString)\n      effects.exit(types.codeFencedFenceInfo)\n      return factorySpace(effects, metaBefore, types.whitespace)(code)\n    }\n\n    if (code === codes.graveAccent && code === marker) {\n      return nok(code)\n    }\n\n    effects.consume(code)\n    return info\n  }\n\n  /**\n   * In opening fence, after info and whitespace, before meta.\n   *\n   * ```markdown\n   * > | ~~~js eval\n   *           ^\n   *   | alert(1)\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function metaBefore(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return infoBefore(code)\n    }\n\n    effects.enter(types.codeFencedFenceMeta)\n    effects.enter(types.chunkString, {contentType: constants.contentTypeString})\n    return meta(code)\n  }\n\n  /**\n   * In meta.\n   *\n   * ```markdown\n   * > | ~~~js eval\n   *           ^\n   *   | alert(1)\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function meta(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.chunkString)\n      effects.exit(types.codeFencedFenceMeta)\n      return infoBefore(code)\n    }\n\n    if (code === codes.graveAccent && code === marker) {\n      return nok(code)\n    }\n\n    effects.consume(code)\n    return meta\n  }\n\n  /**\n   * At eol/eof in code, before a non-lazy closing fence or content.\n   *\n   * ```markdown\n   * > | ~~~js\n   *          ^\n   * > | alert(1)\n   *             ^\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function atNonLazyBreak(code) {\n    assert(markdownLineEnding(code), 'expected eol')\n    return effects.attempt(closeStart, after, contentBefore)(code)\n  }\n\n  /**\n   * Before code content, not a closing fence, at eol.\n   *\n   * ```markdown\n   *   | ~~~js\n   * > | alert(1)\n   *             ^\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function contentBefore(code) {\n    assert(markdownLineEnding(code), 'expected eol')\n    effects.enter(types.lineEnding)\n    effects.consume(code)\n    effects.exit(types.lineEnding)\n    return contentStart\n  }\n\n  /**\n   * Before code content, not a closing fence.\n   *\n   * ```markdown\n   *   | ~~~js\n   * > | alert(1)\n   *     ^\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function contentStart(code) {\n    return initialPrefix > 0 && markdownSpace(code)\n      ? factorySpace(\n          effects,\n          beforeContentChunk,\n          types.linePrefix,\n          initialPrefix + 1\n        )(code)\n      : beforeContentChunk(code)\n  }\n\n  /**\n   * Before code content, after optional prefix.\n   *\n   * ```markdown\n   *   | ~~~js\n   * > | alert(1)\n   *     ^\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function beforeContentChunk(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return effects.check(nonLazyContinuation, atNonLazyBreak, after)(code)\n    }\n\n    effects.enter(types.codeFlowValue)\n    return contentChunk(code)\n  }\n\n  /**\n   * In code content.\n   *\n   * ```markdown\n   *   | ~~~js\n   * > | alert(1)\n   *     ^^^^^^^^\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function contentChunk(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.codeFlowValue)\n      return beforeContentChunk(code)\n    }\n\n    effects.consume(code)\n    return contentChunk\n  }\n\n  /**\n   * After code.\n   *\n   * ```markdown\n   *   | ~~~js\n   *   | alert(1)\n   * > | ~~~\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    effects.exit(types.codeFenced)\n    return ok(code)\n  }\n\n  /**\n   * @this {TokenizeContext}\n   * @type {Tokenizer}\n   */\n  function tokenizeCloseStart(effects, ok, nok) {\n    let size = 0\n\n    return startBefore\n\n    /**\n     *\n     *\n     * @type {State}\n     */\n    function startBefore(code) {\n      assert(markdownLineEnding(code), 'expected eol')\n      effects.enter(types.lineEnding)\n      effects.consume(code)\n      effects.exit(types.lineEnding)\n      return start\n    }\n\n    /**\n     * Before closing fence, at optional whitespace.\n     *\n     * ```markdown\n     *   | ~~~js\n     *   | alert(1)\n     * > | ~~~\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n    function start(code) {\n      // Always populated by defaults.\n      assert(\n        self.parser.constructs.disable.null,\n        'expected `disable.null` to be populated'\n      )\n\n      // To do: `enter` here or in next state?\n      effects.enter(types.codeFencedFence)\n      return markdownSpace(code)\n        ? factorySpace(\n            effects,\n            beforeSequenceClose,\n            types.linePrefix,\n            self.parser.constructs.disable.null.includes('codeIndented')\n              ? undefined\n              : constants.tabSize\n          )(code)\n        : beforeSequenceClose(code)\n    }\n\n    /**\n     * In closing fence, after optional whitespace, at sequence.\n     *\n     * ```markdown\n     *   | ~~~js\n     *   | alert(1)\n     * > | ~~~\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n    function beforeSequenceClose(code) {\n      if (code === marker) {\n        effects.enter(types.codeFencedFenceSequence)\n        return sequenceClose(code)\n      }\n\n      return nok(code)\n    }\n\n    /**\n     * In closing fence sequence.\n     *\n     * ```markdown\n     *   | ~~~js\n     *   | alert(1)\n     * > | ~~~\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n    function sequenceClose(code) {\n      if (code === marker) {\n        size++\n        effects.consume(code)\n        return sequenceClose\n      }\n\n      if (size >= sizeOpen) {\n        effects.exit(types.codeFencedFenceSequence)\n        return markdownSpace(code)\n          ? factorySpace(effects, sequenceCloseAfter, types.whitespace)(code)\n          : sequenceCloseAfter(code)\n      }\n\n      return nok(code)\n    }\n\n    /**\n     * After closing fence sequence, after optional whitespace.\n     *\n     * ```markdown\n     *   | ~~~js\n     *   | alert(1)\n     * > | ~~~\n     *        ^\n     * ```\n     *\n     * @type {State}\n     */\n    function sequenceCloseAfter(code) {\n      if (code === codes.eof || markdownLineEnding(code)) {\n        effects.exit(types.codeFencedFence)\n        return ok(code)\n      }\n\n      return nok(code)\n    }\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeNonLazyContinuation(effects, ok, nok) {\n  const self = this\n\n  return start\n\n  /**\n   *\n   *\n   * @type {State}\n   */\n  function start(code) {\n    if (code === codes.eof) {\n      return nok(code)\n    }\n\n    assert(markdownLineEnding(code), 'expected eol')\n    effects.enter(types.lineEnding)\n    effects.consume(code)\n    effects.exit(types.lineEnding)\n    return lineStart\n  }\n\n  /**\n   *\n   *\n   * @type {State}\n   */\n  function lineStart(code) {\n    return self.parser.lazy[self.now().line] ? nok(code) : ok(code)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}